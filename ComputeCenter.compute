#pragma kernel PlayerShoot
#pragma kernel UpdatePlayerBulletPosition
#pragma kernel CullPlayerBullet
#pragma kernel ProcessPlayerBulletCollision
#pragma kernel UpdateDrawPlayerBulletArgs
#pragma kernel CreateSphereEnemy
#pragma kernel CullSphereEnemy
#pragma kernel UpdateEnemyVelocityAndPosition
#pragma kernel ProcessPlayerEnemyCollision
#pragma kernel EnemyShoot
#pragma kernel UpdateEnemyBulletVelocityAndPosition
#pragma kernel CullEnemyBullet
#pragma kernel UpdateDrawEnemyBulletArgs
#pragma kernel ProcessEnemyBulletCollision
#pragma kernel BuildPlayerBulletGrid
#pragma kernel BuildEnemyBulletGrid
#pragma kernel ResetBulletGrid
#pragma kernel ProcessBulletBulletCollision
#pragma kernel UpdateDrawEnemyArgs
#pragma kernel SkillTransferBulletType
#pragma kernel SkillGetAvailablePosition
#pragma kernel UpdateDeployingEnemy
#pragma kernel ResetBulletRenderingGrid
#pragma kernel ResolveBulletRenderingGrid1x1
#pragma kernel ResolveBulletRenderingGrid2x2
#pragma kernel ResolveBulletRenderingGrid4x4
#pragma kernel ResolveEnemyCollision1
#pragma kernel ResolveEnemyCollision2
#pragma kernel ApplyEnemyGravity
#pragma kernel ResetPlaneLightingTexture
#pragma kernel GeneratePlaneLightingTexture
#pragma kernel ResolvePlaneLightingTexture
#pragma kernel GaussianBlurU
#pragma kernel GaussianBlurV


#define DEG2RAD_V 0.01745329252f

uint GetNegative(uint num)
{
    return 0xFFFFFFFF - num + 1;
}

float Random3DTo1D(float3 value, float a, float3 b)
{
    float3 smallValue = sin(value);
    float random = dot(smallValue, b);
    random = frac(sin(random) * a);
    return random;
}

float3 Random3DTo3D(float3 value)
{
    return float3(
		Random3DTo1D(value, 14375.5964, float3(15.637, 76.243, 37.168)),
		Random3DTo1D(value, 14684.6034, float3(45.366, 23.168, 65.918)),
		Random3DTo1D(value, 17635.1739, float3(62.654, 88.467, 25.111))
	);
}

float3 RotateAroundY(float3 vec, float angle)
{
    angle *= DEG2RAD_V;
    
    float cosTheta = cos(angle);
    float sinTheta = sin(angle);
    
    float3 result;
    result.x = cosTheta * vec.x + sinTheta * vec.z;
    result.y = vec.y;
    result.z = -sinTheta * vec.x + cosTheta * vec.z;
    
    return result;
}


struct PlayerDatum
{
    float3 pos;
    int hpChange;
    int3 hitImpulse;
    float size;
    uint hittable;
    int hitByEnemy;
    float3 dir;
    float tmp1;
    float tmp2;
    float tmp3;
};


struct PlayerSkillDatum
{
    int player1Skill0;
    int player1Skill1;
    int player2Skill0;
    int player2Skill1;
    int sharedSkill0;
    int sharedSkill1;
    int player2Skill0HPRestoration;
    float3 player1Skill1AimingPointPosition;
    int player2Skill0HitEnemy;
    float tmp2;
};

struct BulletDatum
{
    float3 pos;
    float3 dir;
    float speed;
    float radius;
    int damage;
    uint bounces;
    float expirationTime;
    float impulse;
    float virtualY;
    uint packedInfo;
    float renderingBiasY;
    uint color;
};

struct EnemyDatum
{
    float3 pos;
    float3 velocity;
    int maxHP;
    int hp;
    float size;
    float radius;
    int3 hitImpulse;
    int weapon;
    float lastShootTime;
    float originalM;
    float m;
    float acceleration;
    float frictionalDeceleration;
    float maxSpeed;
    uint baseColor;
    float lastHitByPlayer2Skill0Time;
    float createdTime;
    float tmp;
};

struct EnemyCollisionCacheDatum
{
    float3 deltaPos;
    float3 deltaVelocity;
};

struct EnemyWeaponDatum
{
    float uniformRandomAngleBias;
    float individualRandomAngleBias;
    float shootInterval;
    int extraBulletsPerSide;
    float angle;
    float randomShootDelay;
    float bulletSpeed;
    float bulletRadius;
    int bulletDamage;
    int bulletBounces;
    float bulletLifeSpan;
    float bulletImpulse;
    float virtualYRange;
    float tmp1;
    float tmp2;
    float tmp3;
};

struct AvailablePositionDatum
{
    float3 pos1;
    float3 pos2;
    int num;
    int tmp;
};

#define BULLET_GRID_CAPACITY 28
struct BulletGridDatum
{
    int size;
    float tmp1;
    float tmp2;
    float tmp3;
    int bulletIndexList[BULLET_GRID_CAPACITY];
};

struct BulletRenderingGridDatum
{
    int size;
    float3 pos[4];
    float3 color[4];
};

RWStructuredBuffer<PlayerDatum> playerData;

RWStructuredBuffer<PlayerSkillDatum> playerSkillData;

RWStructuredBuffer<BulletDatum> playerBulletData;
RWStructuredBuffer<BulletDatum> culledPlayerBulletData;
RWStructuredBuffer<int> playerBulletNum;
RWStructuredBuffer<int> culledPlayerBulletNum;

RWStructuredBuffer<BulletDatum> playerShootRequestData;

RWStructuredBuffer<BulletGridDatum> playerBulletGridData;
RWStructuredBuffer<BulletGridDatum> enemyBulletGridData;

RWStructuredBuffer<BulletRenderingGridDatum> bulletRenderingGridData1x1;
RWStructuredBuffer<BulletRenderingGridDatum> bulletRenderingGridData2x2;
RWStructuredBuffer<BulletRenderingGridDatum> bulletRenderingGridData4x4;

RWStructuredBuffer<EnemyDatum> sphereEnemyData;
RWStructuredBuffer<EnemyDatum> culledSphereEnemyData;
RWStructuredBuffer<int> sphereEnemyNum;
RWStructuredBuffer<int> culledSphereEnemyNum;

RWStructuredBuffer<EnemyCollisionCacheDatum> enemyCollisionCacheData;

RWStructuredBuffer<EnemyDatum> deployingSphereEnemyData;
RWStructuredBuffer<EnemyDatum> culledDeployingSphereEnemyData;
RWStructuredBuffer<int> deployingSphereEnemyNum;
RWStructuredBuffer<int> culledDeployingSphereEnemyNum;

RWStructuredBuffer<EnemyDatum> createSphereEnemyRequestData;

RWStructuredBuffer<BulletDatum> enemyBulletData;
RWStructuredBuffer<BulletDatum> culledEnemyBulletData;
RWStructuredBuffer<int> enemyBulletNum;
RWStructuredBuffer<int> culledEnemyBulletNum;

RWStructuredBuffer<EnemyWeaponDatum> enemyWeaponData;

RWStructuredBuffer<int> drawPlayerBulletArgs;
RWStructuredBuffer<int> drawSphereEnemyArgs;
RWStructuredBuffer<int> drawEnemyBulletArgs;
RWStructuredBuffer<int> drawDeployingSphereEnemyArgs;

RWStructuredBuffer<AvailablePositionDatum> availablePositionData;

RWStructuredBuffer<int> deadEnemyNum;

RWTexture2D<float4> planeLightingTexture;
RWTexture2D<float4> planeLightingTextureTmp;

float planeLightingTextureWidth;
float planeLightingTextureHeight;
float3 planeSizeInv;
float4 planeLightingGaussianBlurWeight[7];

int playerShootRequestNum;
int createSphereEnemyRequestNum;
float deltaTime;
float gameTime;
float3 player1Pos;
float3 player2Pos;

float viewFrustrumZMin;
float viewFrustrumZMax;
float viewFrustrumXAtZMin;
float viewFrustrumXAtZMax;
float viewFrustrumCullingLerpCoefficient;

float enemySpacingAcceleration;
float enemyCollisionVelocityRestitution;

float gravity;
float planeXMin;
float planeXMax;
float planeZMin;
float planeZMax;

int bulletGridLengthX;
int bulletGridLengthZ;
float3 bulletGridBottomLeftPos;
float bulletGridSize;
float bulletGridSizeInv;

uint packedPlayer1BulletColor;
uint packedPlayer2BulletColor;

groupshared EnemyDatum enemyData[128];
groupshared int enemyNum = 0;

float player2Skill0TMax;

uint GetBit(uint packedInfo, int index)
{
    return (packedInfo >> index) & 1;
}

void SetBit(inout uint packedInfo, int index, int value)
{
    if (value == 0)
        packedInfo &= ~(1 << index);
    else
        packedInfo |= 1 << index;
}

int GetBulletGridIndexFromId(int3 xyz)
{
    xyz = clamp(xyz, int3(0, 0, 0), int3(bulletGridLengthX - 1, 0, bulletGridLengthZ - 1));
    return xyz.z * bulletGridLengthX + xyz.x;
}

int GetBulletGridIndexFromPos(float3 pos)
{
    int3 xyz = floor((pos - bulletGridBottomLeftPos + 0.00001f) * bulletGridSizeInv);
    xyz = clamp(xyz, int3(0, 0, 0), int3(bulletGridLengthX - 1, 0, bulletGridLengthZ - 1));
    return xyz.z * bulletGridLengthX + xyz.x;
}

int GetBulletGridIndexFromXZ(int x, int z)
{
    return z * bulletGridLengthX + x;
}

bool IsInViewFrustum(float3 pos, float radius)
{   
    if (pos.z + radius < viewFrustrumZMin) return false;
    if (pos.z - radius > viewFrustrumZMax) return false;
    
    float xBound = lerp(
        viewFrustrumXAtZMin,
        viewFrustrumXAtZMax,
        (pos.z - viewFrustrumZMin) * viewFrustrumCullingLerpCoefficient
    );
    
    if (pos.x + radius < -xBound) return false;
    if (pos.x - radius > xBound) return false;
    
    return true;
}

bool InThePlane(float3 pos)
{
    bool ret = true;
    return (pos.x >= planeXMin - 0.5f) &&
        (pos.x < planeXMax + 0.5f) &&
        (pos.z > planeZMin - 0.5f) &&
        (pos.z < planeZMax + 0.5f) &&
        (pos.y >= 0.1f);
}

float3 PackedUIntColorToFloat3(uint color)
{
    float3 ret;
    ret.r = (color >> 24 & 255) / 255.0f;
    ret.g = (color >> 16 & 255) / 255.0f;
    ret.b = (color >> 8 & 255) / 255.0f;
    
    return ret;
}


[numthreads(256, 1, 1)]
void PlayerShoot(uint3 id : SV_DispatchThreadID)
{
    if (id.x < playerShootRequestNum)
    {
        int index;
        InterlockedAdd(playerBulletNum[0], 1, index);
        playerBulletData[index] = playerShootRequestData[id.x];
    }
}


[numthreads(128, 1, 1)]
void CreateSphereEnemy(uint3 id : SV_DispatchThreadID)
{
    if (id.x < createSphereEnemyRequestNum)
    {
        int index;
        InterlockedAdd(deployingSphereEnemyNum[0], 1, index);
        deployingSphereEnemyData[index] = createSphereEnemyRequestData[id.x];
    }
}


[numthreads(128, 1, 1)]
void UpdateDeployingEnemy(uint3 id : SV_DispatchThreadID)
{
    if (id.x < deployingSphereEnemyNum[0])
    {
        EnemyDatum enemy = deployingSphereEnemyData[id.x];
        int index;
        if (enemy.createdTime > gameTime)
        {
            InterlockedAdd(culledDeployingSphereEnemyNum[0], 1, index);
            culledDeployingSphereEnemyData[index] = enemy;
        }
        else
        {
            InterlockedAdd(sphereEnemyNum[0], 1, index);
            sphereEnemyData[index] = enemy;
        }
    }
}


[numthreads(256, 1, 1)]
void UpdatePlayerBulletPosition(uint3 id : SV_DispatchThreadID)
{
    if (id.x < playerBulletNum[0])
    {
        BulletDatum bullet = playerBulletData[id.x];
        
        if (playerSkillData[0].player1Skill1 == 2 && GetBit(bullet.packedInfo, 1))
        {
            float3 bulletVelocity = bullet.dir * bullet.speed;
            float3 aimingPointPos = playerSkillData[0].player1Skill1AimingPointPosition;
            float3 aimingPointRelativePos = aimingPointPos - bullet.pos;
            bullet.dir += normalize(aimingPointRelativePos) * 0.7f * bullet.speed * deltaTime;
            bullet.dir = normalize(bullet.dir);
            bullet.dir.y = 0.0f;
            if (length(aimingPointRelativePos) < 0.2f)
            {
                SetBit(bullet.packedInfo, 1, 0);
            }
        }
        
        bullet.pos += bullet.speed * bullet.dir * deltaTime;
        playerBulletData[id.x] = bullet;
    }
}


[numthreads(256, 1, 1)]
void UpdateEnemyBulletVelocityAndPosition(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= enemyBulletNum[0]) return;
    
    BulletDatum bullet = enemyBulletData[id.x];
    
    if (playerSkillData[0].player1Skill0 == 1)
    {
        float3 playerDir = (player1Pos - bullet.pos) * float3(1.0f, 0.0f, 1.0f);
        float playerDistance = length(playerDir);
        playerDir = normalize(playerDir);
        float3 bulletVelocity = bullet.speed * bullet.dir;
        bulletVelocity += clamp(1.0f / (playerDistance * playerDistance), 0.2f, 0.3f) * playerDir;
        bullet.speed = lerp(bullet.speed, length(bulletVelocity), 0.1);
        bullet.dir = normalize(bulletVelocity);
        bullet.pos += bulletVelocity * deltaTime;
        enemyBulletData[id.x] = bullet;
    }
    else
    {
        enemyBulletData[id.x].pos = bullet.pos + bullet.speed * bullet.dir * deltaTime;
    }
}


[numthreads(256, 1, 1)]
void CullPlayerBullet(uint3 id : SV_DispatchThreadID)
{
    BulletDatum bullet = playerBulletData[id.x];
    if (id.x < playerBulletNum[0]
        && IsInViewFrustum(bullet.pos, bullet.radius)
        && bullet.expirationTime > gameTime 
        && bullet.bounces > 0)
    {
        int index;
        InterlockedAdd(culledPlayerBulletNum[0], 1, index);
        culledPlayerBulletData[index] = bullet;
    }
}


[numthreads(256, 1, 1)]
void CullEnemyBullet(uint3 id : SV_DispatchThreadID)
{
    BulletDatum bullet = enemyBulletData[id.x];
    if (id.x < enemyBulletNum[0]
        && IsInViewFrustum(bullet.pos, bullet.radius)
        && bullet.expirationTime > gameTime
        && bullet.bounces > 0)
    {
        int index;
        InterlockedAdd(culledEnemyBulletNum[0], 1, index);
        culledEnemyBulletData[index] = bullet;
    }
}


[numthreads(128, 1, 1)]
void CullSphereEnemy(uint3 id : SV_DispatchThreadID)
{
    EnemyDatum enemy = sphereEnemyData[id.x];
    if (id.x < sphereEnemyNum[0])
    {
        if (enemy.pos.y > -10.0f)
        {
            int index;
            InterlockedAdd(culledSphereEnemyNum[0], 1, index);
            culledSphereEnemyData[index] = enemy;
        }
        else
        {
            InterlockedAdd(deadEnemyNum[0], 1);
        }
    }
}


[numthreads(1, 1, 1)]
void UpdateDrawPlayerBulletArgs(uint3 id : SV_DispatchThreadID)
{
    drawPlayerBulletArgs[1] = playerBulletNum[0];
}


[numthreads(1, 1, 1)]
void UpdateDrawEnemyBulletArgs(uint3 id : SV_DispatchThreadID)
{
    drawEnemyBulletArgs[1] = enemyBulletNum[0];
}


[numthreads(1, 1, 1)]
void UpdateDrawEnemyArgs(uint3 id : SV_DispatchThreadID)
{
    drawSphereEnemyArgs[1] = sphereEnemyNum[0];
    drawDeployingSphereEnemyArgs[1] = deployingSphereEnemyNum[0];
}


[numthreads(64, 1, 1)]
void ProcessPlayerBulletCollision(uint3 id : SV_DispatchThreadID)
{
    if (id.x < playerBulletNum[0])
    {
        BulletDatum bullet = playerBulletData[id.x];
   
        for (int i = 0; i < sphereEnemyNum[0]; i++)
        {
            EnemyDatum enemy = sphereEnemyData[i];
            float enemyRadius = enemy.size * 0.5f;
            float3 bulletRelativePos = bullet.pos - enemy.pos;
            
            if (length(bulletRelativePos) <= enemyRadius + bullet.radius)
            {
                InterlockedAdd(sphereEnemyData[i].hp, -bullet.damage);
                float3 normal = normalize(bulletRelativePos);
                float3 impulse = 10000.0f * bullet.impulse * normal * min(0.0f, dot(bullet.dir, normal));
                InterlockedAdd(sphereEnemyData[i].hitImpulse.x, (int)impulse.x);
                InterlockedAdd(sphereEnemyData[i].hitImpulse.z, (int)impulse.z);
                bullet.pos = enemy.pos + (enemyRadius + bullet.radius) * normal;
                bullet.dir -= 2.0f * dot(normal, bullet.dir) * normal;
                bullet.dir.y = 0.0f;
                bullet.dir = normalize(bullet.dir);
                bullet.bounces -= 1;
                SetBit(bullet.packedInfo, 1, 0);
                playerBulletData[id.x] = bullet;
                return;
            }
        }
    }
}
 

[numthreads(256, 1, 1)]
void ProcessEnemyBulletCollision(uint3 id : SV_DispatchThreadID)
{
    if (id.x < enemyBulletNum[0])
    {
        BulletDatum bullet = enemyBulletData[id.x];
   
        for (int i = 0; i < 2; i++)
        {
            PlayerDatum player = playerData[i];
            float playerRadius = player.size * 0.5f;
            float3 bulletRelativePos = bullet.pos - player.pos;
            
            if (length(bulletRelativePos) <= playerRadius + bullet.radius)
            {
                float3 normal = normalize(bulletRelativePos);
                bullet.pos = player.pos + (playerRadius + bullet.radius) * normal;
                bullet.dir -= 2.0f * dot(normal, bullet.dir) * normal;
                bullet.dir.y = 0.0f;
                bullet.dir = normalize(bullet.dir);
                bullet.bounces -= 1;
                if (i == 1 && playerSkillData[0].player2Skill0 == 1)
                {
                    InterlockedAdd(playerSkillData[0].player2Skill0HPRestoration, bullet.damage);
                    bullet.virtualY = 10.0f;
                    SetBit(bullet.packedInfo, 0, 1);
                    bullet.color = packedPlayer2BulletColor;
                    int newIndex;
                    InterlockedAdd(playerBulletNum[0], 1, newIndex);
                    playerBulletData[newIndex] = bullet;
                    enemyBulletData[id.x].pos = float3(-100.0f, 0.0f, -100.0f);
                }
                else
                {
                    InterlockedAdd(playerData[i].hpChange, -bullet.damage);
                    InterlockedAdd(playerData[i].hitImpulse.x, (int) (-normal.x * bullet.impulse * 10000.0f));
                    InterlockedAdd(playerData[i].hitImpulse.z, (int) (-normal.z * bullet.impulse * 10000.0f));
                    enemyBulletData[id.x] = bullet;
                }
                
                return;
            }
        }
    }
}


[numthreads(128, 1, 1)]
void UpdateEnemyVelocityAndPosition(uint3 id : SV_DispatchThreadID)
{
    // apply and clear impulse
    if (id.x < sphereEnemyNum[0])
    {
        EnemyDatum enemy = sphereEnemyData[id.x];
        
        float3 dV = (float3) enemy.hitImpulse * 0.0001 / enemy.m;
        if (length(dV) > 0.001f)
            dV = normalize(dV) * clamp(length(dV), 0.0f, 1.0f);
        enemy.velocity += dV;
        enemy.hitImpulse = int3(0, 0, 0);
        enemy.m = enemy.hp <= 0 ? enemy.originalM * 0.18f : enemy.originalM;
        sphereEnemyData[id.x] = enemy;
    }
    
    GroupMemoryBarrierWithGroupSync();
    
    EnemyDatum enemy;
    // calculate desired velocity
    if (id.x < sphereEnemyNum[0])
    {
        enemy = sphereEnemyData[id.x];
        // move towards player
        float3 player1Pos = playerData[0].pos;
        float3 player2Pos = playerData[1].pos;
        float3 player1RelativePos = player1Pos - enemy.pos;
        float3 player2RelativePos = player2Pos - enemy.pos;
        
        float3 dir;
        if (InThePlane(player1Pos))
        {
            if (InThePlane(player2Pos))
            {
                dir = length(player1RelativePos) < length(player2RelativePos) ?
                player1RelativePos : player2RelativePos;
            }
            else
            {
                dir = player1RelativePos;
            }
            enemy.velocity += enemy.acceleration * normalize(dir * float3(1.0f, 0.0f, 1.0f)) * deltaTime;
            enemy.velocity -= normalize(enemy.velocity) * enemy.frictionalDeceleration * max(0.0f, (length(enemy.velocity) - enemy.maxSpeed)) * deltaTime;
        }
        else
        {
            if (InThePlane(player2Pos))
            {
                dir = player2RelativePos;
                enemy.velocity += enemy.acceleration * normalize(dir * float3(1.0f, 0.0f, 1.0f)) * deltaTime;
                enemy.velocity -= normalize(enemy.velocity) * enemy.frictionalDeceleration * max(0.0f, (length(enemy.velocity) - enemy.maxSpeed)) * deltaTime;
            }
            else
            {
                float dV = min(enemy.acceleration * deltaTime, length(enemy.velocity));
                if (length(enemy.velocity) > 0.01f)
                    enemy.velocity += dV * normalize(-enemy.velocity * float3(1.0f, 0.0f, 1.0f));
                if (length(enemy.velocity) > 0.01f)
                    enemy.velocity -= normalize(enemy.velocity) * enemy.frictionalDeceleration * max(0.0f, (length(enemy.velocity) - enemy.maxSpeed)) * deltaTime;
            }
        }
    }
    
    GroupMemoryBarrierWithGroupSync();
    
    // update position
    if (id.x < sphereEnemyNum[0])
    {
        enemy.pos += enemy.velocity * deltaTime * float3(1.0f, 0.0f, 1.0f);
        sphereEnemyData[id.x] = enemy;
    }
}


[numthreads(128, 1, 1)]
void ResolveEnemyCollision1(uint3 id : SV_DispatchThreadID)
{   
    float3 deltaPos = float3(0.0f, 0.0f, 0.0f);
    float3 deltaVelocity = float3(0.0f, 0.0f, 0.0f);
    if (id.x < sphereEnemyNum[0])
    {
        EnemyDatum enemy = sphereEnemyData[id.x];
        for (int i = 0; i < sphereEnemyNum[0]; i++)
        {
            if (i == id.x)
                continue;
            EnemyDatum another = sphereEnemyData[i];
            float3 relativePos = another.pos - enemy.pos;
            float collisionDistance = length(relativePos) - 0.5f * (enemy.size + another.size);
            float3 normal = normalize(relativePos);
            if (collisionDistance < 0.0f)
            {
                float pushDistance = collisionDistance * (-0.5f) + 0.001f;
                deltaPos += -normal * pushDistance;
                float impulseValue = (1.0f + enemyCollisionVelocityRestitution) * dot(enemy.velocity - another.velocity, normal) / (1.0f / enemy.m + 1.0f / another.m);
                deltaVelocity += -normal * abs(impulseValue) / enemy.m;
            }
        }
        
        enemyCollisionCacheData[id.x].deltaPos = deltaPos;
        enemyCollisionCacheData[id.x].deltaVelocity = deltaVelocity;
    }
}
        

float resolveEnemyCollision2VelocityCoeff;
[numthreads(128, 1, 1)]
void ResolveEnemyCollision2(uint3 id : SV_DispatchThreadID)
{
    if (id.x < sphereEnemyNum[0])
    {
        sphereEnemyData[id.x].pos += enemyCollisionCacheData[id.x].deltaPos;
        float3 newVelocity = sphereEnemyData[id.x].velocity + enemyCollisionCacheData[id.x].deltaVelocity * resolveEnemyCollision2VelocityCoeff;
        if (length(newVelocity) > 0.00001f)
        {
            newVelocity = normalize(newVelocity) * clamp(length(newVelocity), 0.0f, 20.0f);
        }
        else
        {
            sphereEnemyData[id.x].velocity = newVelocity;
        }

    }
}
        
[numthreads(128, 1, 1)]
void ApplyEnemyGravity(uint3 id : SV_DispatchThreadID)
{
    EnemyDatum enemy;
    
    if (id.x < sphereEnemyNum[0])
    {
        enemy = sphereEnemyData[id.x];
        
        // chack whether it is on the plane //
        float maxDistance = -1000.0f;
        float tmp;
        float3 borderAcceleration;
        tmp = planeXMin - enemy.pos.x;
        if (tmp > 0.0f)
        {
            maxDistance = tmp;
            borderAcceleration = float3(-1.0f, 0.0f, 0.0f);
        }
        tmp = enemy.pos.x - planeXMax;
        if (tmp > 0.0f)
        {
            maxDistance = tmp;
            borderAcceleration = float3(1.0f, 0.0f, 0.0f);
        }
        tmp = planeZMin - enemy.pos.z;
        if (tmp > 0.0f)
        {
            maxDistance = tmp;
            borderAcceleration = float3(0.0f, 0.0f, -1.0f);
        }
        tmp = enemy.pos.z - planeZMax;
        if (tmp > 0.0f)
        {
            maxDistance = tmp;
            borderAcceleration = float3(0.0f, 0.0f, 1.0f);
        }

        if (maxDistance <= 0.0f && enemy.velocity.y >= -0.01f)
        {
            sphereEnemyData[id.x].velocity.y = 0.0f;
            sphereEnemyData[id.x].pos.y = 0.5f;
        }
        else
        {
            float YLimit = -10005.0f;
            if (maxDistance > 0.0f && maxDistance < 0.5f && enemy.pos.y > 0.0f)
            {
                YLimit = sqrt(0.25f - maxDistance * maxDistance);
            }
            float maxFallDistance = 0.5f * gravity * deltaTime * deltaTime;
            enemy.pos.y += sphereEnemyData[id.x].velocity.y * deltaTime;
            sphereEnemyData[id.x].pos.y = max(enemy.pos.y, YLimit);
            sphereEnemyData[id.x].velocity.y -= gravity * deltaTime;
            sphereEnemyData[id.x].velocity += borderAcceleration * deltaTime;
        }
    }
}


[numthreads(128, 1, 1)]
void ProcessPlayerEnemyCollision(uint3 id : SV_DispatchThreadID)
{
    if (id.x < sphereEnemyNum[0])
    {
        EnemyDatum enemy = sphereEnemyData[id.x];
        
        for (int i = 0; i < 2; i++)
        {
            PlayerDatum player = playerData[i];
            if (player.hittable)
            {
                float3 relativePos = player.pos - enemy.pos;
                float distance = length(relativePos);
                float minDistance = (player.size + enemy.size) * 0.5;
                if (distance < minDistance)
                {
                    if (playerSkillData[0].player2Skill0 == 1)
                    {
                        if (gameTime - enemy.lastHitByPlayer2Skill0Time >= player2Skill0TMax)
                            enemy.lastHitByPlayer2Skill0Time = gameTime;
                        InterlockedAdd(playerSkillData[0].player2Skill0HitEnemy, 1);
                        float3 dir = normalize(relativePos);
                        enemy.velocity = float3(0.0f, 0.0f, 0.0f);
                        enemy.pos = player.pos - dir * minDistance;
                        float3 dV = -dir * 2.0f;
                        
                        // extra normal impulse
                        float3 playerVelocityNormal = normalize(float3(player.dir.z, 0.0f, -player.dir.x));
                        if (dot(playerVelocityNormal, -dir) > 0.0f)
                            dV += playerVelocityNormal * 4.5f;
                        else
                            dV -= playerVelocityNormal * 4.5f;
                        
                        dV.y = 0.0f;
                        enemy.velocity += dV;
                        
                        sphereEnemyData[id.x] = enemy;
                    }
                    else if (player.hittable == 1)
                    {
                        float3 dir = normalize(relativePos);
                        float3 dV = dir * 12.0f;
                        dV.y = 8.0f;
                        playerData[i].hitByEnemy = 1;
                        playerData[i].hitImpulse = 10000.0f * dV;
                        InterlockedAdd(playerData[i].hpChange, -30);
                    }
                }
            }
        }
    }
}


[numthreads(128, 1, 1)]
void EnemyShoot(uint3 id : SV_DispatchThreadID)
{
    if (id.x < sphereEnemyNum[0])
    {
        EnemyDatum enemy = sphereEnemyData[id.x];
        EnemyWeaponDatum weapon = enemyWeaponData[enemy.weapon];
        float3 r3 = Random3DTo3D(float3(gameTime, deltaTime, float(id.x) + deltaTime));
        
        if (weapon.shootInterval > 0
            && gameTime - enemy.lastShootTime > weapon.shootInterval + weapon.randomShootDelay * r3.x
            && enemy.pos.y > 0.499f)
        {
            sphereEnemyData[id.x].lastShootTime = gameTime;
            
            float3 player1Pos = playerData[0].pos;
            float3 player2Pos = playerData[1].pos;
            
            float3 playerDir;
            float3 player1RelativePos = player1Pos - enemy.pos;
            float3 player2RelativePos = player2Pos - enemy.pos;
            if (InThePlane(player1Pos))
            {
                if (InThePlane(player2Pos))
                {
                    playerDir = length(player1RelativePos) < length(player2RelativePos) ?
                        player1RelativePos : player2RelativePos;
                }
                else
                {
                    playerDir = player1RelativePos;
                }
            }
            else
            {
                if (InThePlane(player2Pos))
                {
                    playerDir = player2RelativePos;
                }
                else
                {
                    return;
                }
            }
            playerDir = normalize(playerDir * float3(1.0f, 0.0f, 1.0f));

            for (int i = -weapon.extraBulletsPerSide; i <= weapon.extraBulletsPerSide; i++)
            {
                int bulletIndex;
                InterlockedAdd(enemyBulletNum[0], 1, bulletIndex);
                BulletDatum bullet = enemyBulletData[bulletIndex];
                float r1 = Random3DTo1D(gameTime, (float)i * 14375.5964, deltaTime) + r3.z;
                 
                bullet.pos = enemy.pos;
                bullet.dir = RotateAroundY(playerDir, i * weapon.angle + weapon.uniformRandomAngleBias * (r3.y * 2.0f - 1.0f));
                bullet.dir.y = 0.0f;
                bullet.speed = weapon.bulletSpeed;
                bullet.radius = weapon.bulletRadius;
                bullet.damage = weapon.bulletDamage;
                bullet.bounces = weapon.bulletBounces;
                bullet.expirationTime = gameTime + weapon.bulletLifeSpan;
                bullet.impulse = weapon.bulletImpulse;
                bullet.virtualY = 0.5f + (r1 - 0.5) * weapon.virtualYRange * 2.0f;
                bullet.color = enemy.baseColor;
                enemyBulletData[bulletIndex] = bullet;
            }
        }
    }
}


[numthreads(256, 1, 1)]
void ResetBulletGrid(uint3 id : SV_DispatchThreadID)
{
    playerBulletGridData[id.x].size = 0;
    enemyBulletGridData[id.x].size = 0;
}


[numthreads(256, 1, 1)]
void BuildPlayerBulletGrid(uint3 id : SV_DispatchThreadID)
{
    if (id.x < playerBulletNum[0])
    {
        float3 pos = playerBulletData[id.x].pos;
        int gridIndex = GetBulletGridIndexFromPos(pos);
        int bulletIndex;
        InterlockedAdd(playerBulletGridData[gridIndex].size, 1, bulletIndex);
        if (bulletIndex < BULLET_GRID_CAPACITY)
        {
            playerBulletGridData[gridIndex].bulletIndexList[bulletIndex] = id.x;
        }
    }
}


[numthreads(256, 1, 1)]
void BuildEnemyBulletGrid(uint3 id : SV_DispatchThreadID)
{
    if (id.x < enemyBulletNum[0])
    {
        float3 pos = enemyBulletData[id.x].pos;
        int gridIndex = GetBulletGridIndexFromPos(pos);
        int bulletIndex;
        InterlockedAdd(enemyBulletGridData[gridIndex].size, 1, bulletIndex);
        if (bulletIndex < BULLET_GRID_CAPACITY)
        {
            enemyBulletGridData[gridIndex].bulletIndexList[bulletIndex] = id.x;
        }
    }
}


[numthreads(8, 1, 8)]
void ProcessBulletBulletCollision(uint3 id : SV_DispatchThreadID)
{
    int gridIndex = GetBulletGridIndexFromId(id);
    for (int i = 0; i < min(playerBulletGridData[gridIndex].size, BULLET_GRID_CAPACITY); i++)
    {
        int playerBulletIndex = playerBulletGridData[gridIndex].bulletIndexList[i];
        BulletDatum playerBullet = playerBulletData[playerBulletIndex];
        for (int gridBiasX = -1; gridBiasX <= 1; gridBiasX++)
        {
            for (int gridBiasZ = -1; gridBiasZ <= 1; gridBiasZ++)
            {
                int neighborGridIndex = GetBulletGridIndexFromId(id + int3(gridBiasX, 0, gridBiasZ));
                for (int j = 0; j < min(enemyBulletGridData[neighborGridIndex].size, BULLET_GRID_CAPACITY); j++)
                {
                    int enemyBulletIndex = enemyBulletGridData[neighborGridIndex].bulletIndexList[j];
                    BulletDatum enemyBullet = enemyBulletData[enemyBulletIndex];
                    float radiusSum = playerBullet.radius + enemyBullet.radius;
                    if (length(playerBullet.pos - enemyBullet.pos) < radiusSum
                        && abs(playerBullet.virtualY - enemyBullet.virtualY) < radiusSum)
                    {
                        playerBulletData[playerBulletIndex].expirationTime = 0.0f;
                        enemyBulletData[enemyBulletIndex].expirationTime = 0.0f;
                    }
                }
            }
        }
    }
}


[numthreads(256, 1, 1)]
void SkillTransferBulletType(uint3 id : SV_DispatchThreadID)
{
    int state = playerSkillData[0].sharedSkill0;
    float player1BulletRate = state == 3 ? 0.8f : 0.2f;
    
    if (id.x < enemyBulletNum[0])
    {
        int index;
        InterlockedAdd(playerBulletNum[0], 1, index);
        float r = Random3DTo1D(gameTime * 100.0f, id.x * 0.5f, index * 0.5f);
        int createdByPlayer1 = r < player1BulletRate;
        BulletDatum bullet = enemyBulletData[id.x];
        bullet.damage = createdByPlayer1 ? 1.0f : 0.3f;
        bullet.impulse = createdByPlayer1 ? 0.5f : 1.0f;
        bullet.renderingBiasY = createdByPlayer1 ? 0.0f : 1.0f;
        SetBit(bullet.packedInfo, 0, createdByPlayer1 ? 0 : 1);
        uint packedColor = createdByPlayer1 ? packedPlayer1BulletColor : packedPlayer2BulletColor;
        bullet.color = packedColor;
        playerBulletData[index] = bullet;
    }
}


// range: x = [-18, 18], z = [-13, 13]
#define TEST_POSITION_START float3(-17.9296875f, 0.5f, -12.94921875)
#define TEST_POSITION_STEP float3(0.140625f, 0.0f, 0.1015625f)
[numthreads(16, 1, 16)]
void SkillGetAvailablePosition(uint3 id : SV_DispatchThreadID)
{
    float3 currentPos = TEST_POSITION_START + TEST_POSITION_STEP * id;
    for (int i = 0; i < sphereEnemyNum[0]; i++)
    {
        if (length(sphereEnemyData[i].pos - currentPos) < 2.0f)
        {
            return;
        }
    }
    
    int index;
    InterlockedAdd(availablePositionData[0].num, 1, index);
    if (index == 0)
    {
        availablePositionData[0].pos1 = currentPos;
    }
    else if (index == 1)
    {
        if (length(availablePositionData[0].pos1 - currentPos) > 2.0f)
        {
            availablePositionData[0].pos2 = currentPos;
        }
        else
        {
            availablePositionData[0].num = 1;
        }
    }
}


[numthreads(256, 1, 1)]
void ResetBulletRenderingGrid(uint3 id : SV_DispatchThreadID)
{
    bulletRenderingGridData1x1[id.x].size = 0;
    bulletRenderingGridData2x2[id.x].size = 0;
    bulletRenderingGridData4x4[id.x].size = 0;
}


[numthreads(8, 1, 8)]
void ResolveBulletRenderingGrid1x1(uint3 id : SV_DispatchThreadID)
{
    int index = GetBulletGridIndexFromId(id);

    for (int i = 0; i < min(playerBulletGridData[index].size, 2); i++)
    {
        BulletDatum bullet = playerBulletData[playerBulletGridData[index].bulletIndexList[i]];
        bool valid = true;
        for (int j = 0; j < sphereEnemyNum[0]; j++)
        {
            if (length(bullet.pos - sphereEnemyData[j].pos) <= 0.5f)
            {
                valid = false;
                break;
            }
        }
        
        if (valid)
        {
            int size = bulletRenderingGridData1x1[index].size;
            bulletRenderingGridData1x1[index].color[size] = PackedUIntColorToFloat3(bullet.color);
            bulletRenderingGridData1x1[index].pos[size] = bullet.pos;
            bulletRenderingGridData1x1[index].size++;
        }
    }
    
    for (int i = 0; i < min(enemyBulletGridData[index].size > 0, 2);i++)
    {
        BulletDatum bullet = enemyBulletData[enemyBulletGridData[index].bulletIndexList[i]];
        bool valid = true;
        for (int j = 0; j < sphereEnemyNum[0]; j++)
        {
            if (length(bullet.pos - sphereEnemyData[j].pos) <= 0.5f)
            {
                valid = false;
                break;
            }
        }
        
        if (valid)
        {
            int size = bulletRenderingGridData1x1[index].size;
            bulletRenderingGridData1x1[index].color[size] = PackedUIntColorToFloat3(bullet.color);
            bulletRenderingGridData1x1[index].pos[size] = bullet.pos;
            bulletRenderingGridData1x1[index].size++;
        }
    }
}


[numthreads(8, 1, 8)]
void ResolveBulletRenderingGrid2x2(uint3 id : SV_DispatchThreadID)
{
    int index = GetBulletGridIndexFromId(id);
    for (int x = id.x; x <= id.x + 1; x++)
    {
        for (int z = id.z; z <= id.z + 1; z++)
        {
            int bulletNum = 0;
            float3 colorSum = float3(0.0f, 0.0f, 0.0f);
            float3 posSum = float3(0.0f, 0.0f, 0.0f);
            int cellIndex = GetBulletGridIndexFromXZ(x, z);
            for (int i = 0; i < bulletRenderingGridData1x1[cellIndex].size; i++)
            {
                bulletNum++;
                colorSum += bulletRenderingGridData1x1[cellIndex].color[i];
                posSum += bulletRenderingGridData1x1[cellIndex].pos[i];
            }
            
            if (bulletNum != 0)
            {
                float bulletNumInv = 1.0f / (float) bulletNum;
                bulletRenderingGridData2x2[index].color[0] = colorSum;
                bulletRenderingGridData2x2[index].pos[0] = posSum * bulletNumInv;
                bulletRenderingGridData2x2[index].size++;
            }
        }
    }
}


// old
[numthreads(8, 1, 8)]
void ResolveBulletRenderingGrid4x4(uint3 id : SV_DispatchThreadID)
{
    int bulletNum = 0;
    float3 colorSum = float3(0.0f, 0.0f, 0.0f);
    float3 posSum = float3(0.0f, 0.0f, 0.0f);
    for (int x = id.x; x <= id.x + 2; x += 2)
    {
        for (int z = id.z; z <= id.z + 2; z += 2)
        {
            int cellIndex = GetBulletGridIndexFromXZ(x, z);
            for (int i = 0; i < bulletRenderingGridData2x2[cellIndex].size; i++)
            {
                bulletNum += 1;
                colorSum += bulletRenderingGridData1x1[cellIndex].color[i];
                posSum += bulletRenderingGridData1x1[cellIndex].pos[i];
            }
        }
    }

    int index = GetBulletGridIndexFromId(id);
    if (bulletNum != 0)
    {
        float bulletNumInv = 1.0f / (float) bulletNum;
        bulletRenderingGridData4x4[index].color[0] = colorSum * bulletNumInv;
        bulletRenderingGridData4x4[index].pos[0] = posSum * bulletNumInv;
        bulletRenderingGridData4x4[index].size = 1;
    }
}


[numthreads(32, 1, 32)]
void ResetPlaneLightingTexture(uint3 id : SV_DispatchThreadID)
{
    planeLightingTexture[id.xz] = float4(0.0f, 0.0f, 0.0f, 0.0f);
}


[numthreads(256, 1, 1)]
void GeneratePlaneLightingTexture(uint3 id : SV_DispatchThreadID)
{
    if (id.x < playerBulletNum[0])
    {
        float3 pos = playerBulletData[id.x].pos;
        float3 color = PackedUIntColorToFloat3(playerBulletData[id.x].color);

        if (pos.y >= 0.0f && pos.y <= 0.6f)
        {
            int3 texIndex = floor((pos - float3(planeXMin, 0.5f, planeZMin)) * planeSizeInv *
                float3(planeLightingTextureWidth, 0.0f, planeLightingTextureHeight));
            planeLightingTexture[texIndex.xz] += float4(color, 1.0f);
        }
    }
    
    if (id.x < enemyBulletNum[0])
    {
        float3 pos = enemyBulletData[id.x].pos;
        float3 color = PackedUIntColorToFloat3(enemyBulletData[id.x].color);

        if (pos.y >= 0.0f && pos.y <= 0.6f)
        {
            int3 texIndex = floor((pos - float3(planeXMin, 0.5f, planeZMin)) * planeSizeInv *
                float3(planeLightingTextureWidth, 0.0f, planeLightingTextureHeight));
            planeLightingTexture[texIndex.xz] += float4(color, 1.0f);
        }
    }
}

[numthreads(16, 16, 1)]
void ResolvePlaneLightingTexture(uint3 id : SV_DispatchThreadID)
{
    float4 data = planeLightingTexture[id.xy];
    float weight = pow(data.a, 0.1f);
    planeLightingTexture[id.xy] = float4(data.rgb * weight, 1.0f);
}


[numthreads(160, 1, 1)]
void GaussianBlurU(uint3 id : SV_DispatchThreadID)
{
    float3 result = float3(0.0f, 0.0f, 0.0f);
    for (int i = 0; i < 7; i++)
    {
        result += planeLightingGaussianBlurWeight[i].x * planeLightingTexture[id.xy + int2(i - 3, 0)];
    }
    planeLightingTextureTmp[id.xy] = float4(result, 1.0f);
}

[numthreads(1, 150, 1)]
void GaussianBlurV(uint3 id : SV_DispatchThreadID)
{
    float3 result = float3(0.0f, 0.0f, 0.0f);
    for (int i = 0; i < 7; i++)
    {
        result += planeLightingGaussianBlurWeight[i].x * planeLightingTextureTmp[id.xy + int2(0, i - 3)];
    }
    planeLightingTexture[id.xy] = float4(result, 1.0f);
}
