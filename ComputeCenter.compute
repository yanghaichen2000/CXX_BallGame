#pragma kernel PlayerShoot
#pragma kernel UpdatePlayerBulletPosition
#pragma kernel CullPlayerBullet
#pragma kernel ProcessPlayerBulletCollision
#pragma kernel UpdateDrawPlayerBulletArgs
#pragma kernel CreateSphereEnemy
#pragma kernel CullSphereEnemy
#pragma kernel UpdateEnemyPosition
#pragma kernel ProcessPlayerEnemyCollision
#pragma kernel EnemyShoot
#pragma kernel UpdateEnemyBulletPosition
#pragma kernel CullEnemyBullet
#pragma kernel UpdateDrawEnemyBulletArgs

#define DEG2RAD_V 0.01745329252f

uint GetNegative(uint num)
{
    return 0xFFFFFFFF - num + 1;
}

float Random3DTo1D(float3 value, float a, float3 b)
{
    float3 smallValue = sin(value);
    float random = dot(smallValue, b);
    random = frac(sin(random) * a);
    return random;
}

float3 Random3DTo3D(float3 value)
{
    return float3(
		Random3DTo1D(value, 14375.5964, float3(15.637, 76.243, 37.168)),
		Random3DTo1D(value, 14684.6034, float3(45.366, 23.168, 65.918)),
		Random3DTo1D(value, 17635.1739, float3(62.654, 88.467, 25.111))
	);
}

float3 RotateAroundY(float3 vec, float angle)
{
    angle *= DEG2RAD_V;
    
    float cosTheta = cos(angle);
    float sinTheta = sin(angle);
    
    float3 result;
    result.x = cosTheta * vec.x + sinTheta * vec.z;
    result.y = vec.y;
    result.z = -sinTheta * vec.x + cosTheta * vec.z;
    
    return result;
}


struct PlayerDatum
{
    float3 pos;
    int hp;
    float3 hitMomentum;
    float size;
    uint hittable;
    float tmp1;
    float tmp2;
    float tmp3;
};

struct BulletDatum
{
    float3 pos;
    float3 dir;
    float speed;
    float radius;
    int damage;
    uint bounces;
    float expirationTime;
    uint tmp1;
};

struct EnemyDatum
{
    float3 pos;
    float3 dir;
    int hp;
    float size;
    float rotationY;
    float radius;
    float speed;
    float maxSpeed;
    int weapon;
    float lastShootTime;
    float tmp3;
    float tmp4;
};

struct EnemyWeaponDatum
{
    float uniformRandomAngleBias;
    float individualRandomAngleBias;
    float shootInterval;
    int extraBulletsPerSide;
    float angle;
    float randomShootDelay;
    float bulletSpeed;
    float bulletRadius;
    int bulletDamage;
    int bulletBounces;
    float bulletLifeSpan;
    float tmp3;
};

RWStructuredBuffer<PlayerDatum> playerData;

RWStructuredBuffer<BulletDatum> playerBulletData;
RWStructuredBuffer<BulletDatum> culledPlayerBulletData;
RWStructuredBuffer<int> playerBulletNum;
RWStructuredBuffer<int> culledPlayerBulletNum;

RWStructuredBuffer<BulletDatum> playerShootRequestData;

RWStructuredBuffer<EnemyDatum> sphereEnemyData;
RWStructuredBuffer<int> sphereEnemyNum;

RWStructuredBuffer<EnemyDatum> createSphereEnemyRequestData;

RWStructuredBuffer<BulletDatum> enemyBulletData;
RWStructuredBuffer<BulletDatum> culledEnemyBulletData;
RWStructuredBuffer<int> enemyBulletNum;
RWStructuredBuffer<int> culledEnemyBulletNum;

RWStructuredBuffer<EnemyWeaponDatum> enemyWeaponData;

RWStructuredBuffer<int> drawPlayerBulletArgs;
RWStructuredBuffer<int> drawSphereEnemyArgs;
RWStructuredBuffer<int> drawEnemyBulletArgs;

int playerShootRequestNum;
int createSphereEnemyRequestNum;
float deltaTime;
float gameTime;
float3 player1Pos;
float3 player2Pos;

groupshared EnemyDatum enemyData[128];
groupshared int enemyNum = 0;


[numthreads(128, 1, 1)]
void PlayerShoot(uint3 id : SV_DispatchThreadID)
{
    if (id.x < playerShootRequestNum)
    {
        int index = playerBulletNum[0] + id.x;
        playerBulletData[index] = playerShootRequestData[id.x];
    }

    GroupMemoryBarrierWithGroupSync();
    
    if (id.x == 0)
        playerBulletNum[0] += playerShootRequestNum;
}


[numthreads(128, 1, 1)]
void CreateSphereEnemy(uint3 id : SV_DispatchThreadID)
{
    if (id.x < createSphereEnemyRequestNum)
    {
        int index = sphereEnemyNum[0] + id.x;
        sphereEnemyData[index] = createSphereEnemyRequestData[id.x];
    }
    
    GroupMemoryBarrierWithGroupSync();
    
    if (id.x == 0)
        sphereEnemyNum[0] += createSphereEnemyRequestNum;
}


[numthreads(64, 1, 1)]
void UpdatePlayerBulletPosition(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= playerBulletNum[0]) return;
    BulletDatum bullet = playerBulletData[id.x];
    playerBulletData[id.x].pos = bullet.pos + bullet.speed * bullet.dir * deltaTime;
}


[numthreads(64, 1, 1)]
void UpdateEnemyBulletPosition(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= enemyBulletNum[0]) return;
    BulletDatum bullet = enemyBulletData[id.x];
    enemyBulletData[id.x].pos = bullet.pos + bullet.speed * bullet.dir * deltaTime;
}


[numthreads(64, 1, 1)]
void CullPlayerBullet(uint3 id : SV_DispatchThreadID)
{
    BulletDatum bullet = playerBulletData[id.x];
    if (id.x < playerBulletNum[0] && bullet.expirationTime > gameTime && bullet.bounces > 0)
    {
        int index;
        InterlockedAdd(culledPlayerBulletNum[0], 1, index);
        culledPlayerBulletData[index] = bullet;
    }
}


[numthreads(64, 1, 1)]
void CullEnemyBullet(uint3 id : SV_DispatchThreadID)
{
    BulletDatum bullet = enemyBulletData[id.x];
    if (id.x < enemyBulletNum[0] && bullet.expirationTime > gameTime && bullet.bounces > 0)
    {
        int index;
        InterlockedAdd(culledEnemyBulletNum[0], 1, index);
        culledEnemyBulletData[index] = bullet;
    }
}


[numthreads(128, 1, 1)]
void CullSphereEnemy(uint3 id : SV_DispatchThreadID)
{
    EnemyDatum enemy;
    if (id.x < sphereEnemyNum[0])
    {
        enemy = sphereEnemyData[id.x];
    }
    int historySphereEnemyNum = sphereEnemyNum[0];
    
    GroupMemoryBarrierWithGroupSync();
    
    if (id.x == 0)
        sphereEnemyNum[0] = 0;

    if (id.x < historySphereEnemyNum && enemy.hp > 0) 
    {
        int index;
        InterlockedAdd(sphereEnemyNum[0], 1, index);
        sphereEnemyData[index] = enemy;
    }
    
    GroupMemoryBarrierWithGroupSync();
    
    if (id.x == 0)
        drawSphereEnemyArgs[1] = sphereEnemyNum[0];
}


[numthreads(1, 1, 1)]
void UpdateDrawPlayerBulletArgs(uint3 id : SV_DispatchThreadID)
{
    drawPlayerBulletArgs[1] = playerBulletNum[0];
}


[numthreads(1, 1, 1)]
void UpdateDrawEnemyBulletArgs(uint3 id : SV_DispatchThreadID)
{
    drawEnemyBulletArgs[1] = enemyBulletNum[0];
}


[numthreads(64, 1, 1)]
void ProcessPlayerBulletCollision(uint3 id : SV_DispatchThreadID)
{
    BulletDatum bullet = playerBulletData[id.x];
    
    for (int i = 0; i < sphereEnemyNum[0]; i++)
    {
        EnemyDatum enemy = sphereEnemyData[i];
        float enemyRadius = enemy.size * 0.5f;
        float3 bulletRelativePos = bullet.pos - enemy.pos;
            
        if (length(bulletRelativePos) <= enemyRadius + bullet.radius)
        {
            InterlockedAdd(sphereEnemyData[i].hp, -bullet.damage);
            float3 normal = normalize(bulletRelativePos);
            bullet.pos = enemy.pos + (enemyRadius + bullet.radius) * normal;
            bullet.dir -= 2.0f * dot(normal, bullet.dir) * normal;
            bullet.dir.y = 0.0f;
            bullet.dir = normalize(bullet.dir);
            bullet.bounces -= 1;
            playerBulletData[id.x] = bullet;
            return;
        }
    }
}


[numthreads(128, 1, 1)]
void UpdateEnemyPosition(uint3 id : SV_DispatchThreadID)
{
    if (id.x == 0)
        enemyNum = 0;
    
    GroupMemoryBarrierWithGroupSync();
    
    EnemyDatum datum;
    int index;
    if (id.x < sphereEnemyNum[0])
    {
        datum = sphereEnemyData[id.x];
        InterlockedAdd(enemyNum, 1, index);
        enemyData[index] = datum;
    }
    
    GroupMemoryBarrierWithGroupSync();
    
    if (id.x < sphereEnemyNum[0])
    {
        datum.speed = lerp(datum.speed, datum.maxSpeed, 0.5f);
        
        float3 playerRelativePos = player1Pos - datum.pos;
        float playerDistance = length(playerRelativePos);
        float moveDistance = min(playerDistance, datum.speed * deltaTime);
        float3 newPos = datum.pos + normalize(playerRelativePos) * moveDistance;

        int i;
        for (i = 0; i < enemyNum; i++)
        {            
            if (i == index) continue;
            EnemyDatum enemy = enemyData[i];
            float3 desiredRelativePos = newPos - datum.pos;
            float3 enemyRelativePos = enemy.pos - datum.pos;
            float distance = length(enemyRelativePos);
            float newDistance = length(enemy.pos - newPos);
            if (newDistance < enemy.radius + datum.radius && newDistance < distance)
            {
                newPos -= 1.0f * dot(desiredRelativePos, normalize(enemyRelativePos)) * enemyRelativePos;
            }
        }
        
        newPos.y = 0.5f;
        datum.pos = newPos;
        
        for (i = 0; i < enemyNum; i++)
        {
            if (i == index) continue;
            EnemyDatum enemy = enemyData[i];
            if (length(enemy.pos - newPos) < enemy.radius + datum.radius)
            {
                datum.speed *= 0.5f;
                break;
            }
        }
        
        sphereEnemyData[id.x] = datum;
    }
}


[numthreads(128, 1, 1)]
void ProcessPlayerEnemyCollision(uint3 id : SV_DispatchThreadID)
{
    if (id.x < sphereEnemyNum[0])
    {
        EnemyDatum enemy = sphereEnemyData[id.x];
        
        for (int i = 0; i < 2; i++)
        {
            PlayerDatum player = playerData[i];
            if (player.hittable)
            {
                float3 relativePos = player.pos - enemy.pos;
                float distance = length(relativePos);
                if (player.hittable == 1 && distance < (player.size + enemy.size) * 0.5)
                {
                    float3 dir = normalize(relativePos);
                    float3 newMomentum = dir * 10.0f;
                    playerData[i].hitMomentum = newMomentum;
                    InterlockedAdd(playerData[i].hp, -30);
                }
            }
        }
    }
}


[numthreads(128, 1, 1)]
void EnemyShoot(uint3 id : SV_DispatchThreadID)
{
    if (id.x < sphereEnemyNum[0])
    {
        EnemyDatum enemy = sphereEnemyData[id.x];
        EnemyWeaponDatum weapon = enemyWeaponData[enemy.weapon];
        float3 r = Random3DTo3D(float3(gameTime, deltaTime, float(id.x) + deltaTime));
        
        if (gameTime - enemy.lastShootTime > weapon.shootInterval + weapon.randomShootDelay * r.x)
        {
            sphereEnemyData[id.x].lastShootTime = gameTime;
            float3 playerDir = normalize(player1Pos - enemy.pos);
            
            for (int i = -weapon.extraBulletsPerSide; i <= weapon.extraBulletsPerSide; i++)
            {
                int bulletIndex;
                InterlockedAdd(enemyBulletNum[0], 1, bulletIndex);
                BulletDatum bullet = enemyBulletData[bulletIndex];
                
                bullet.pos = enemy.pos;
                bullet.dir = RotateAroundY(playerDir, i * weapon.angle + weapon.uniformRandomAngleBias * (r.y * 2.0f - 1.0f));
                bullet.speed = weapon.bulletSpeed;
                bullet.radius = weapon.bulletRadius;
                bullet.damage = weapon.bulletDamage;
                bullet.bounces = weapon.bulletBounces;
                bullet.expirationTime = gameTime + weapon.bulletLifeSpan;
                enemyBulletData[bulletIndex] = bullet;
            }
        }
    }
}
