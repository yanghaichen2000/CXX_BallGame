#pragma kernel PlayerShoot
#pragma kernel UpdatePlayerBulletPosition
#pragma kernel CullPlayerBullet
#pragma kernel ProcessPlayerBulletCollision
#pragma kernel UpdateDrawPlayerBulletArgs
#pragma kernel CreateSphereEnemy
#pragma kernel CullSphereEnemy
#pragma kernel UpdateEnemyVelocityAndPosition
#pragma kernel ProcessPlayerEnemyCollision
#pragma kernel EnemyShoot
#pragma kernel UpdateEnemyBulletPosition
#pragma kernel CullEnemyBullet
#pragma kernel UpdateDrawEnemyBulletArgs
#pragma kernel ProcessEnemyBulletCollision
#pragma kernel BuildPlayerBulletGrid
#pragma kernel BuildEnemyBulletGrid
#pragma kernel ResetBulletGrid
#pragma kernel ProcessBulletBulletCollision

#define DEG2RAD_V 0.01745329252f

uint GetNegative(uint num)
{
    return 0xFFFFFFFF - num + 1;
}

float Random3DTo1D(float3 value, float a, float3 b)
{
    float3 smallValue = sin(value);
    float random = dot(smallValue, b);
    random = frac(sin(random) * a);
    return random;
}

float3 Random3DTo3D(float3 value)
{
    return float3(
		Random3DTo1D(value, 14375.5964, float3(15.637, 76.243, 37.168)),
		Random3DTo1D(value, 14684.6034, float3(45.366, 23.168, 65.918)),
		Random3DTo1D(value, 17635.1739, float3(62.654, 88.467, 25.111))
	);
}

float3 RotateAroundY(float3 vec, float angle)
{
    angle *= DEG2RAD_V;
    
    float cosTheta = cos(angle);
    float sinTheta = sin(angle);
    
    float3 result;
    result.x = cosTheta * vec.x + sinTheta * vec.z;
    result.y = vec.y;
    result.z = -sinTheta * vec.x + cosTheta * vec.z;
    
    return result;
}


struct PlayerDatum
{
    float3 pos;
    int hpChange;
    int3 hitImpulse;
    float size;
    uint hittable;
    float tmp1;
    int hitByEnemy;
    float tmp3;
};

struct BulletDatum
{
    float3 pos;
    float3 dir;
    float speed;
    float radius;
    int damage;
    uint bounces;
    float expirationTime;
    float impulse;
    float virtualY;
    int player;
    int tmp1;
    float tmp2;
};

struct EnemyDatum
{
    float3 pos;
    float3 velocity;
    int hp;
    float size;
    float radius;
    int3 hitImpulse;
    int weapon;
    float lastShootTime;
    float originalM;
    float m;
};

struct EnemyWeaponDatum
{
    float uniformRandomAngleBias;
    float individualRandomAngleBias;
    float shootInterval;
    int extraBulletsPerSide;
    float angle;
    float randomShootDelay;
    float bulletSpeed;
    float bulletRadius;
    int bulletDamage;
    int bulletBounces;
    float bulletLifeSpan;
    float bulletImpulse;
    float virtualYRange;
    float tmp1;
    float tmp2;
    float tmp3;
};

#define BULLET_GRID_CAPACITY 28
struct BulletGridDatum
{
    int size;
    float tmp1;
    float tmp2;
    float tmp3;
    int bulletIndexList[BULLET_GRID_CAPACITY];
};


RWStructuredBuffer<PlayerDatum> playerData;

RWStructuredBuffer<BulletDatum> playerBulletData;
RWStructuredBuffer<BulletDatum> culledPlayerBulletData;
RWStructuredBuffer<int> playerBulletNum;
RWStructuredBuffer<int> culledPlayerBulletNum;

RWStructuredBuffer<BulletDatum> playerShootRequestData;

RWStructuredBuffer<BulletGridDatum> playerBulletGridData;
RWStructuredBuffer<BulletGridDatum> enemyBulletGridData;

RWStructuredBuffer<EnemyDatum> sphereEnemyData;
RWStructuredBuffer<int> sphereEnemyNum;

RWStructuredBuffer<EnemyDatum> createSphereEnemyRequestData;

RWStructuredBuffer<BulletDatum> enemyBulletData;
RWStructuredBuffer<BulletDatum> culledEnemyBulletData;
RWStructuredBuffer<int> enemyBulletNum;
RWStructuredBuffer<int> culledEnemyBulletNum;

RWStructuredBuffer<EnemyWeaponDatum> enemyWeaponData;

RWStructuredBuffer<int> drawPlayerBulletArgs;
RWStructuredBuffer<int> drawSphereEnemyArgs;
RWStructuredBuffer<int> drawEnemyBulletArgs;

int playerShootRequestNum;
int createSphereEnemyRequestNum;
float deltaTime;
float gameTime;
float3 player1Pos;
float3 player2Pos;

float viewFrustrumZMin;
float viewFrustrumZMax;
float viewFrustrumXAtZMin;
float viewFrustrumXAtZMax;
float viewFrustrumCullingLerpCoefficient;

float enemyAcceleration;
float enemyMaxSpeed;
float enemyFrictionalDeceleration;
float enemySpacingAcceleration;
float enemyCollisionVelocityRestitution;

float gravity;
float planeXMin;
float planeXMax;
float planeZMin;
float planeZMax;

int bulletGridLengthX;
int bulletGridLengthZ;
float3 bulletGridBottomLeftPos;
float bulletGridSize;
float bulletGridSizeInv;

groupshared EnemyDatum enemyData[128];
groupshared int enemyNum = 0;


int GetBulletGridIndexFromId(int3 xyz)
{
    xyz = clamp(xyz, int3(0, 0, 0), int3(bulletGridLengthX - 1, 0, bulletGridLengthZ - 1));
    return xyz.z * bulletGridLengthX + xyz.x;
}

int GetBulletGridIndexFromPos(float3 pos)
{
    int3 xyz = floor((pos - bulletGridBottomLeftPos + 0.00001f) * bulletGridSizeInv);
    xyz = clamp(xyz, int3(0, 0, 0), int3(bulletGridLengthX - 1, 0, bulletGridLengthZ - 1));
    return xyz.z * bulletGridLengthX + xyz.x;
}

bool IsInViewFrustum(float3 pos, float radius)
{   
    if (pos.z + radius < viewFrustrumZMin) return false;
    if (pos.z - radius > viewFrustrumZMax) return false;
    
    float xBound = lerp(
        viewFrustrumXAtZMin,
        viewFrustrumXAtZMax,
        (pos.z - viewFrustrumZMin) * viewFrustrumCullingLerpCoefficient
    );
    
    if (pos.x + radius < -xBound) return false;
    if (pos.x - radius > xBound) return false;
    
    return true;
}


[numthreads(256, 1, 1)]
void PlayerShoot(uint3 id : SV_DispatchThreadID)
{
    if (id.x < playerShootRequestNum)
    {
        int index;
        InterlockedAdd(playerBulletNum[0], 1, index);
        playerBulletData[index] = playerShootRequestData[id.x];
    }
}


[numthreads(128, 1, 1)]
void CreateSphereEnemy(uint3 id : SV_DispatchThreadID)
{
    if (id.x < createSphereEnemyRequestNum)
    {
        int index;
        InterlockedAdd(sphereEnemyNum[0], 1, index);
        sphereEnemyData[index] = createSphereEnemyRequestData[id.x];
    }
}


[numthreads(256, 1, 1)]
void UpdatePlayerBulletPosition(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= playerBulletNum[0]) return;
    BulletDatum bullet = playerBulletData[id.x];
    playerBulletData[id.x].pos = bullet.pos + bullet.speed * bullet.dir * deltaTime;
}


[numthreads(256, 1, 1)]
void UpdateEnemyBulletPosition(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= enemyBulletNum[0]) return;
    BulletDatum bullet = enemyBulletData[id.x];
    enemyBulletData[id.x].pos = bullet.pos + bullet.speed * bullet.dir * deltaTime;
}


[numthreads(256, 1, 1)]
void CullPlayerBullet(uint3 id : SV_DispatchThreadID)
{
    BulletDatum bullet = playerBulletData[id.x];
    if (id.x < playerBulletNum[0]
        && IsInViewFrustum(bullet.pos, bullet.radius)
        && bullet.expirationTime > gameTime 
        && bullet.bounces > 0)
    {
        int index;
        InterlockedAdd(culledPlayerBulletNum[0], 1, index);
        culledPlayerBulletData[index] = bullet;
    }
}


[numthreads(256, 1, 1)]
void CullEnemyBullet(uint3 id : SV_DispatchThreadID)
{
    BulletDatum bullet = enemyBulletData[id.x];
    if (id.x < enemyBulletNum[0]
        && IsInViewFrustum(bullet.pos, bullet.radius)
        && bullet.expirationTime > gameTime
        && bullet.bounces > 0)
    {
        int index;
        InterlockedAdd(culledEnemyBulletNum[0], 1, index);
        culledEnemyBulletData[index] = bullet;
    }
}


[numthreads(64, 1, 1)]
void CullSphereEnemy(uint3 id : SV_DispatchThreadID)
{
    EnemyDatum enemy;
    if (id.x < sphereEnemyNum[0])
    {
        enemy = sphereEnemyData[id.x];
    }
    int historySphereEnemyNum = sphereEnemyNum[0];
    
    GroupMemoryBarrierWithGroupSync();
    
    if (id.x == 0)
        sphereEnemyNum[0] = 0;

    if (id.x < historySphereEnemyNum) 
    {
        int index;
        InterlockedAdd(sphereEnemyNum[0], 1, index);
        sphereEnemyData[index] = enemy;
    }
    
    GroupMemoryBarrierWithGroupSync();
    
    if (id.x == 0)
        drawSphereEnemyArgs[1] = sphereEnemyNum[0];
}


[numthreads(1, 1, 1)]
void UpdateDrawPlayerBulletArgs(uint3 id : SV_DispatchThreadID)
{
    drawPlayerBulletArgs[1] = playerBulletNum[0];
}


[numthreads(1, 1, 1)]
void UpdateDrawEnemyBulletArgs(uint3 id : SV_DispatchThreadID)
{
    drawEnemyBulletArgs[1] = enemyBulletNum[0];
}


[numthreads(128, 1, 1)]
void ProcessPlayerBulletCollision(uint3 id : SV_DispatchThreadID)
{
    if (id.x < playerBulletNum[0])
    {
        BulletDatum bullet = playerBulletData[id.x];
   
        for (int i = 0; i < sphereEnemyNum[0]; i++)
        {
            EnemyDatum enemy = sphereEnemyData[i];
            float enemyRadius = enemy.size * 0.5f;
            float3 bulletRelativePos = bullet.pos - enemy.pos;
            
            if (length(bulletRelativePos) <= enemyRadius + bullet.radius)
            {
                InterlockedAdd(sphereEnemyData[i].hp, -bullet.damage);
                float3 normal = normalize(bulletRelativePos);
                float3 impulse = 10000.0f * bullet.impulse * normal * min(0.0f, dot(bullet.dir, normal));
                InterlockedAdd(sphereEnemyData[i].hitImpulse.x, (int)impulse.x);
                InterlockedAdd(sphereEnemyData[i].hitImpulse.z, (int)impulse.z);
                bullet.pos = enemy.pos + (enemyRadius + bullet.radius) * normal;
                bullet.dir -= 2.0f * dot(normal, bullet.dir) * normal;
                bullet.dir.y = 0.0f;
                bullet.dir = normalize(bullet.dir);
                bullet.bounces -= 1;
                playerBulletData[id.x] = bullet;
                return;
            }
        }
    }
}
 

[numthreads(256, 1, 1)]
void ProcessEnemyBulletCollision(uint3 id : SV_DispatchThreadID)
{
    if (id.x < enemyBulletNum[0])
    {
        BulletDatum bullet = enemyBulletData[id.x];
   
        for (int i = 0; i < 2; i++)
        {
            PlayerDatum player = playerData[i];
            float playerRadius = player.size * 0.5f;
            float3 bulletRelativePos = bullet.pos - player.pos;
            
            if (length(bulletRelativePos) <= playerRadius + bullet.radius)
            {
                InterlockedAdd(playerData[i].hpChange, -bullet.damage);
                float3 normal = normalize(bulletRelativePos);
                InterlockedAdd(playerData[i].hitImpulse.x, (int)(-normal.x * bullet.impulse * 10000.0f));
                InterlockedAdd(playerData[i].hitImpulse.z, (int)(-normal.z * bullet.impulse * 10000.0f));
                bullet.pos = player.pos + (playerRadius + bullet.radius) * normal;
                bullet.dir -= 2.0f * dot(normal, bullet.dir) * normal;
                bullet.dir.y = 0.0f;
                bullet.dir = normalize(bullet.dir);
                bullet.bounces -= 1;
                enemyBulletData[id.x] = bullet;
                return;
            }
        }
    }
}


[numthreads(128, 1, 1)]
void UpdateEnemyVelocityAndPosition(uint3 id : SV_DispatchThreadID)
{    
    // apply and clear impulse
    float enemy_m = 0.0f; /////////////////// do this
    if (id.x < sphereEnemyNum[0])
    {
        EnemyDatum enemy = sphereEnemyData[id.x];
        enemy.velocity += (float3)enemy.hitImpulse * 0.0001 / enemy.m;
        enemy.hitImpulse = int3(0, 0, 0);
        enemy.m = enemy.hp <= 0 ? enemy.originalM * 0.2f : enemy.originalM;
        enemyData[id.x] = enemy;
    }
    if (id.x == 0) enemyNum = sphereEnemyNum[0];
    
    GroupMemoryBarrierWithGroupSync();
    
    EnemyDatum enemy;
    // calculate desired velocity
    if (id.x < enemyNum)
    {
        enemy = enemyData[id.x];
        // move towards player
        enemy.velocity += enemyAcceleration * normalize((playerData[0].pos - enemy.pos) * float3(1.0f, 0.0f, 1.0f)) * deltaTime;
        // frictional deceleration
        enemy.velocity -= normalize(enemy.velocity) * enemyFrictionalDeceleration * max(0.0f, (length(enemy.velocity) - enemyMaxSpeed)) * deltaTime;
        // TODO: try to control the distance to other enemies

    }
    
    GroupMemoryBarrierWithGroupSync();
    
    // update position
    if (id.x < enemyNum)
    {
        enemy.pos += enemy.velocity * deltaTime * float3(1.0f, 0.0f, 1.0f);
        enemyData[id.x] = enemy;
    }
    
    GroupMemoryBarrierWithGroupSync();
    
    // deal with collisions
    for (int itr = 0; itr < 3; itr++)
    {
        float3 deltaPos = float3(0.0f, 0.0f, 0.0f);
        float3 deltaVelocity = float3(0.0f, 0.0f, 0.0f);
        if (id.x < enemyNum)
        {
            enemy = enemyData[id.x];
            for (int i = 0; i < enemyNum; i++)
            {
                if (i == id.x) continue;
                EnemyDatum another = enemyData[i];
                float3 relativePos = another.pos - enemy.pos;
                float collisionDistance = length(relativePos) - 0.5f * (enemy.size + another.size);
                float3 normal = normalize(relativePos);
                if (collisionDistance < 0.0f)
                {
                    float pushDistance = collisionDistance * (-0.5f) + 0.001f;
                    deltaPos += -normal * pushDistance;
                    
                    float impulseValue = (1.0f + enemyCollisionVelocityRestitution) * dot(enemy.velocity - another.velocity, normal) / (1.0f / enemy.m + 1.0f / another.m);
                    deltaVelocity += -normal * abs(impulseValue) / enemy.m;
                }
            }
        }
        
        GroupMemoryBarrierWithGroupSync();
        
        if (id.x < enemyNum)
        {
            enemyData[id.x].pos += deltaPos;
            enemyData[id.x].velocity += deltaVelocity;
        }
        
        GroupMemoryBarrierWithGroupSync();
    }
    
    // apply gravity
    if (id.x < enemyNum)
    {
        enemy = enemyData[id.x];
        
        // chack whether it is on the plane //
        float maxDistance = -1000.0f;
        float tmp;
        float3 borderAcceleration;
        tmp = planeXMin - enemy.pos.x;
        if (tmp > 0.0f)
        {
            maxDistance = tmp;
            borderAcceleration = float3(-1.0f, 0.0f, 0.0f);
        }
        tmp = enemy.pos.x - planeXMax;
        if (tmp > 0.0f)
        {
            maxDistance = tmp;
            borderAcceleration = float3(1.0f, 0.0f, 0.0f);
        }
        tmp = planeZMin - enemy.pos.z;
        if (tmp > 0.0f)
        {
            maxDistance = tmp;
            borderAcceleration = float3(0.0f, 0.0f, -1.0f);
        }
        tmp = enemy.pos.z - planeZMax;
        if (tmp > 0.0f)
        {
            maxDistance = tmp;
            borderAcceleration = float3(0.0f, 0.0f, 1.0f);
        }

        if (maxDistance <= 0.0f && enemy.velocity.y >= -0.01f)
        {
            enemyData[id.x].velocity.y = 0.0f;
            enemyData[id.x].pos.y = 0.5f;
        }
        else
        {
            float YLimit = -10000.0f;
            if (maxDistance > 0.0f && maxDistance < 0.5f && enemy.pos.y > 0.0f)
            {
                YLimit = sqrt(0.25f - maxDistance * maxDistance);
            }
            float maxFallDistance = 0.5f * gravity * deltaTime * deltaTime;
            enemy.pos.y += enemyData[id.x].velocity.y * deltaTime;
            enemyData[id.x].pos.y = max(enemy.pos.y, YLimit);
            enemyData[id.x].velocity.y -= gravity * deltaTime;
            enemyData[id.x].velocity += borderAcceleration * deltaTime;
        }
    }
    
    // update data
    if (id.x < enemyNum)
    {
        sphereEnemyData[id.x] = enemyData[id.x];
    }
}


[numthreads(128, 1, 1)]
void ProcessPlayerEnemyCollision(uint3 id : SV_DispatchThreadID)
{
    if (id.x < sphereEnemyNum[0])
    {
        EnemyDatum enemy = sphereEnemyData[id.x];
        
        for (int i = 0; i < 2; i++)
        {
            PlayerDatum player = playerData[i];
            if (player.hittable)
            {
                float3 relativePos = player.pos - enemy.pos;
                float distance = length(relativePos);
                if (player.hittable == 1 && distance < (player.size + enemy.size) * 0.5)
                {
                    float3 dir = normalize(relativePos);
                    float3 dV = dir * 12.0f;
                    dV.y = 12.0f;
                    playerData[i].hitByEnemy = 1;
                    playerData[i].hitImpulse = 10000.0f * dV;
                    InterlockedAdd(playerData[i].hpChange, -30);
                }
            }
        }
    }
}


[numthreads(128, 1, 1)]
void EnemyShoot(uint3 id : SV_DispatchThreadID)
{
    if (id.x < sphereEnemyNum[0])
    {
        EnemyDatum enemy = sphereEnemyData[id.x];
        EnemyWeaponDatum weapon = enemyWeaponData[enemy.weapon];
        float3 r3 = Random3DTo3D(float3(gameTime, deltaTime, float(id.x) + deltaTime));
        
        if (weapon.shootInterval > 0
            && gameTime - enemy.lastShootTime > weapon.shootInterval + weapon.randomShootDelay * r3.x
            && enemy.pos.y > 0.499f)
        {
            sphereEnemyData[id.x].lastShootTime = gameTime;
            float3 playerDir = normalize((player1Pos - enemy.pos) * float3(1.0f, 0.0f, 1.0f));
            
            for (int i = -weapon.extraBulletsPerSide; i <= weapon.extraBulletsPerSide; i++)
            {
                int bulletIndex;
                InterlockedAdd(enemyBulletNum[0], 1, bulletIndex);
                BulletDatum bullet = enemyBulletData[bulletIndex];
                float r1 = Random3DTo1D(gameTime, (float)i * 14375.5964, deltaTime) + r3.z;
                 
                bullet.pos = enemy.pos;
                bullet.dir = RotateAroundY(playerDir, i * weapon.angle + weapon.uniformRandomAngleBias * (r3.y * 2.0f - 1.0f));
                bullet.dir.y = 0.0f;
                bullet.speed = weapon.bulletSpeed;
                bullet.radius = weapon.bulletRadius;
                bullet.damage = weapon.bulletDamage;
                bullet.bounces = weapon.bulletBounces;
                bullet.expirationTime = gameTime + weapon.bulletLifeSpan;
                bullet.impulse = weapon.bulletImpulse;
                bullet.virtualY = 0.5f + (r1 - 0.5) * weapon.virtualYRange * 2.0f;
                enemyBulletData[bulletIndex] = bullet;
            }
        }
    }
}


[numthreads(256, 1, 1)]
void ResetBulletGrid(uint3 id : SV_DispatchThreadID)
{
    playerBulletGridData[id.x].size = 0;
    enemyBulletGridData[id.x].size = 0;
}


[numthreads(256, 1, 1)]
void BuildPlayerBulletGrid(uint3 id : SV_DispatchThreadID)
{
    if (id.x < playerBulletNum[0])
    {
        float3 pos = playerBulletData[id.x].pos;
        int gridIndex = GetBulletGridIndexFromPos(pos);
        int bulletIndex;
        InterlockedAdd(playerBulletGridData[gridIndex].size, 1, bulletIndex);
        if (bulletIndex < BULLET_GRID_CAPACITY)
        {
            playerBulletGridData[gridIndex].bulletIndexList[bulletIndex] = id.x;
        }
    }
}


[numthreads(256, 1, 1)]
void BuildEnemyBulletGrid(uint3 id : SV_DispatchThreadID)
{
    if (id.x < enemyBulletNum[0])
    {
        float3 pos = enemyBulletData[id.x].pos;
        int gridIndex = GetBulletGridIndexFromPos(pos);
        int bulletIndex;
        InterlockedAdd(enemyBulletGridData[gridIndex].size, 1, bulletIndex);
        if (bulletIndex < BULLET_GRID_CAPACITY)
        {
            enemyBulletGridData[gridIndex].bulletIndexList[bulletIndex] = id.x;
        }
    }
}


[numthreads(8, 1, 8)]
void ProcessBulletBulletCollision(uint3 id : SV_DispatchThreadID)
{
    int gridIndex = GetBulletGridIndexFromId(id);
    for (int i = 0; i < min(playerBulletGridData[gridIndex].size, BULLET_GRID_CAPACITY); i++)
    {
        int playerBulletIndex = playerBulletGridData[gridIndex].bulletIndexList[i];
        BulletDatum playerBullet = playerBulletData[playerBulletIndex];
        for (int gridBiasX = -1; gridBiasX <= 1; gridBiasX++)
        {
            for (int gridBiasZ = -1; gridBiasZ <= 1; gridBiasZ++)
            {
                int neighborGridIndex = GetBulletGridIndexFromId(id + int3(gridBiasX, 0, gridBiasZ));
                for (int j = 0; j < min(enemyBulletGridData[neighborGridIndex].size, BULLET_GRID_CAPACITY); j++)
                {
                    int enemyBulletIndex = enemyBulletGridData[neighborGridIndex].bulletIndexList[j];
                    BulletDatum enemyBullet = enemyBulletData[enemyBulletIndex];
                    float radiusSum = playerBullet.radius + enemyBullet.radius;
                    if (length(playerBullet.pos - enemyBullet.pos) < radiusSum
                        && abs(playerBullet.virtualY - enemyBullet.virtualY) < radiusSum)
                    {
                        playerBulletData[playerBulletIndex].expirationTime = 0.0f;
                        enemyBulletData[enemyBulletIndex].expirationTime = 0.0f;
                    }
                }
            }
        }
    }
}
