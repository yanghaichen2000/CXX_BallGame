#pragma kernel PlayerShoot
#pragma kernel BossShoot
#pragma kernel UpdatePlayerBulletPosition
#pragma kernel CullPlayerBullet
#pragma kernel ProcessPlayerBulletCollision
#pragma kernel UpdateDrawPlayerBulletArgs
#pragma kernel CreateSphereEnemy
#pragma kernel CullSphereEnemy
#pragma kernel UpdateEnemyVelocityAndPosition
#pragma kernel ProcessPlayerEnemyCollision
#pragma kernel EnemyShoot
#pragma kernel UpdateEnemyBulletVelocityAndPosition
#pragma kernel CullEnemyBullet
#pragma kernel UpdateDrawEnemyBulletArgs
#pragma kernel ProcessEnemyBulletCollision
#pragma kernel BuildPlayerBulletGrid
#pragma kernel BuildEnemyBulletGrid
#pragma kernel ResetBulletGrid
#pragma kernel ProcessBulletBulletCollision
#pragma kernel UpdateDrawEnemyArgs
#pragma kernel SkillTransferBulletType
#pragma kernel SkillGetAvailablePosition
#pragma kernel UpdateDeployingEnemy
#pragma kernel ResetBulletRenderingGrid
#pragma kernel ResolveBulletRenderingGrid1x1
#pragma kernel ResolveBulletRenderingGrid2x2
#pragma kernel ResolveBulletRenderingGrid4x4
#pragma kernel ResolveEnemyCollision1
#pragma kernel ResolveEnemyCollision2
#pragma kernel ApplyEnemyGravity
#pragma kernel ResetPlaneLightingTexture
#pragma kernel GeneratePlaneLightingTexture
#pragma kernel ResolvePlaneLightingTexture
#pragma kernel GaussianBlurU
#pragma kernel GaussianBlurV
#pragma kernel ProcessPlayerBulletBossCollision
#pragma kernel KnockOutAllEnemy
#pragma kernel ProcessBossEnemyCollision
#pragma kernel PhysicallyBasedBlur
#pragma kernel CopyTexture
#pragma kernel CopyTextureAndReverseY
#pragma kernel DFTStepU
#pragma kernel DFTStepV
#pragma kernel IDFTStepU
#pragma kernel IDFTStepV
#pragma kernel PlaneLightingFrequencyDomainMultiply
#pragma kernel InitializePlaneLightingTemporalConvolutionKernel
#pragma kernel PadPlaneLightingTexture
#pragma kernel ClearEnemyGrid
#pragma kernel BuildEnemyGrid

#define DEG2RAD_V 0.01745329252f
#define PI 3.14159265359f
#define SQRT2INV 0.70710678119f

struct ComplexFloat3
{
    float3 real;
    float3 imag;
};

inline ComplexFloat3 ComplexMul(ComplexFloat3 a, float2 b)
{
    ComplexFloat3 ret;
    ret.real = a.real * b.x - a.imag * b.y;
    ret.imag = a.real * b.y + a.imag * b.x;
    return ret;
}

inline float2 ComplexMul(float2 a, float2 b)
{
    return float2(
        a.x * b.x - a.y * b.y,
        a.x * b.y + a.y * b.x
        );
}

inline float2 angleToComplex(float theta)
{
    return float2(cos(theta), sin(theta));
}

inline uint GetNegative(uint num)
{
    return 0xFFFFFFFF - num + 1;
}

inline float Random3DTo1D(float3 value, float a, float3 b)
{
    float3 smallValue = sin(value);
    float random = dot(smallValue, b);
    random = frac(sin(random) * a);
    return random;
}

inline float3 Random3DTo3D(float3 value)
{
    return float3(
		Random3DTo1D(value, 14375.5964, float3(15.637, 76.243, 37.168)),
		Random3DTo1D(value, 14684.6034, float3(45.366, 23.168, 65.918)),
		Random3DTo1D(value, 17635.1739, float3(62.654, 88.467, 25.111))
	);
}

inline float3 RotateAroundY(float3 vec, float angle)
{
    angle *= DEG2RAD_V;
    
    float cosTheta = cos(angle);
    float sinTheta = sin(angle);
    
    float3 result;
    result.x = cosTheta * vec.x + sinTheta * vec.z;
    result.y = vec.y;
    result.z = -sinTheta * vec.x + cosTheta * vec.z;
    
    return result;
}


struct PlayerDatum
{
    float3 pos;
    int hpChange;
    int3 hitImpulse;
    float size;
    uint hittable;
    int hitByEnemy;
    float3 velocity;
    float3 tmp;
};


struct PlayerSkillDatum
{
    int player1Skill0;
    int player1Skill1;
    int player2Skill0;
    int player2Skill1;
    int sharedSkill0;
    int sharedSkill1;
    int player2Skill0HPRestoration;
    float3 player1Skill1AimingPointPosition;
    int player2Skill0HitEnemy;
    float tmp2;
};

struct BulletDatum
{
    float3 pos;
    float3 dir;
    float speed;
    float radius;
    int damage;
    uint bounces;
    float expirationTime;
    float impulse;
    float virtualY;
    uint packedInfo;
    float renderingBiasY;
    uint color;
};

struct EnemyDatum
{
    float3 pos;
    float3 velocity;
    int maxHP;
    int hp;
    float size;
    float radius;
    int3 hitImpulse;
    int weapon;
    float lastShootTime;
    float originalM;
    float m;
    float acceleration;
    float frictionalDeceleration;
    float maxSpeed;
    uint baseColor;
    float lastHitByPlayer2Skill0Time;
    float createdTime;
    int knockedOutByBoss;
};

struct EnemyCollisionCacheDatum
{
    float3 deltaPos;
    float3 deltaVelocity;
};

struct EnemyWeaponDatum
{
    float uniformRandomAngleBias;
    float individualRandomAngleBias;
    float shootInterval;
    int extraBulletsPerSide;
    float angle;
    float randomShootDelay;
    float bulletSpeed;
    float bulletRadius;
    int bulletDamage;
    int bulletBounces;
    float bulletLifeSpan;
    float bulletImpulse;
    float virtualYRange;
    float tmp1;
    float tmp2;
    float tmp3;
};

struct AvailablePositionDatum
{
    float3 pos1;
    float3 pos2;
    int num;
    int tmp;
};

#define BULLET_GRID_CAPACITY 28
struct BulletGridDatum
{
    int size;
    float tmp1;
    float tmp2;
    float tmp3;
    int bulletIndexList[BULLET_GRID_CAPACITY];
};

struct EnemyGridDatum
{
    int size;
    int index[3];
};

struct BulletRenderingGridDatum
{
    int size;
    float3 pos[4];
    float3 color[4];
};

struct BossDatum
{
    float3 pos;
    int hpChange;
    int3 hitImpulse;
    float tmp;
    float3 velocity;
    float tmp1;
    float4 tmp2;
};

RWStructuredBuffer<PlayerDatum> playerData;

RWStructuredBuffer<BossDatum> bossData;

RWStructuredBuffer<PlayerSkillDatum> playerSkillData;

RWStructuredBuffer<BulletDatum> playerBulletData;
RWStructuredBuffer<BulletDatum> culledPlayerBulletData;
RWStructuredBuffer<int> playerBulletNum;
RWStructuredBuffer<int> culledPlayerBulletNum;

RWStructuredBuffer<BulletDatum> playerShootRequestData;
RWStructuredBuffer<BulletDatum> bossShootRequestData;

RWStructuredBuffer<BulletGridDatum> playerBulletGridData;
RWStructuredBuffer<BulletGridDatum> enemyBulletGridData;

RWStructuredBuffer<EnemyGridDatum> enemyGridData;

RWStructuredBuffer<BulletRenderingGridDatum> bulletRenderingGridData1x1;
RWStructuredBuffer<BulletRenderingGridDatum> bulletRenderingGridData2x2;
RWStructuredBuffer<BulletRenderingGridDatum> bulletRenderingGridData4x4;

RWStructuredBuffer<EnemyDatum> sphereEnemyData;
RWStructuredBuffer<EnemyDatum> culledSphereEnemyData;
RWStructuredBuffer<int> sphereEnemyNum;
RWStructuredBuffer<int> culledSphereEnemyNum;

RWStructuredBuffer<EnemyCollisionCacheDatum> enemyCollisionCacheData;

RWStructuredBuffer<EnemyDatum> deployingSphereEnemyData;
RWStructuredBuffer<EnemyDatum> culledDeployingSphereEnemyData;
RWStructuredBuffer<int> deployingSphereEnemyNum;
RWStructuredBuffer<int> culledDeployingSphereEnemyNum;

RWStructuredBuffer<EnemyDatum> createSphereEnemyRequestData;

RWStructuredBuffer<BulletDatum> enemyBulletData;
RWStructuredBuffer<BulletDatum> culledEnemyBulletData;
RWStructuredBuffer<int> enemyBulletNum;
RWStructuredBuffer<int> culledEnemyBulletNum;

RWStructuredBuffer<EnemyWeaponDatum> enemyWeaponData;

RWStructuredBuffer<int> drawPlayerBulletArgs;
RWStructuredBuffer<int> drawSphereEnemyArgs;
RWStructuredBuffer<int> drawEnemyBulletArgs;
RWStructuredBuffer<int> drawDeployingSphereEnemyArgs;

RWStructuredBuffer<AvailablePositionDatum> availablePositionData;

RWStructuredBuffer<int> deadEnemyNum;

RWTexture2D<float4> planeLightingTexture;
RWTexture2D<float4> planeLightingTextureTmp;

RWTexture2D<float4> textureFrom;
RWTexture2D<float4> textureTo;

RWTexture2D<float4> fftInReal;
RWTexture2D<float4> fftInImag;
RWTexture2D<float4> fftOutReal;
RWTexture2D<float4> fftOutImag;

RWTexture2D<float4> planeLightingConvolutionKernel;

int fftTextureSize;
int fftButterflySize;
float idftScale;

float planeLightingTextureWidth;
float planeLightingTextureHeight;
float planeLightingTexturePixelSizeX;
float planeLightingTexturePixelSizeY;
float3 planeSizeInv;
float4 planeLightingGaussianBlurWeight[7];

int playerShootRequestNum;
int bossShootRequestNum;
int createSphereEnemyRequestNum;
float deltaTime;
float gameTime;
float3 player1Pos;
float3 player2Pos;

float viewFrustrumZMin;
float viewFrustrumZMax;
float viewFrustrumXAtZMin;
float viewFrustrumXAtZMax;
float viewFrustrumCullingLerpCoefficient;

float enemySpacingAcceleration;
float enemyCollisionVelocityRestitution;

float gravity;
float planeXMin;
float planeXMax;
float planeZMin;
float planeZMax;

int bulletGridLengthX;
int bulletGridLengthZ;
float3 bulletGridBottomLeftPos;
float bulletGridSize;
float bulletGridSizeInv;

int enemyGridLengthX;
int enemyGridLengthZ;
int enemyGridLength;
float3 enemyGridBottomLeftPos;
float enemyGridSize;
float enemyGridSizeInv;

uint packedPlayer1BulletColor;
uint packedPlayer2BulletColor;

float player2Skill0TMax;


inline ComplexFloat3 GetFFTComplexColor(int2 index)
{
    ComplexFloat3 ret;
    ret.real = fftInReal[index].xyz;
    ret.imag = fftInImag[index].xyz;
    return ret;
}

inline void SetFFTComplexColor(int2 index, ComplexFloat3 result1, ComplexFloat3 result2, bool add)
{
    if (add)
    {
        fftOutReal[index] = float4((result1.real + result2.real) * SQRT2INV, 0.0f);
        fftOutImag[index] = float4((result1.imag + result2.imag) * SQRT2INV, 0.0f);
    }
    else
    {
        fftOutReal[index] = float4((result1.real - result2.real) * SQRT2INV, 0.0f);
        fftOutImag[index] = float4((result1.imag - result2.imag) * SQRT2INV, 0.0f);
    } 
}

inline uint GetBit(uint packedInfo, int index)
{
    return (packedInfo >> index) & 1;
}

inline void SetBit(inout uint packedInfo, int index, int value)
{
    if (value == 0)
        packedInfo &= ~(1 << index);
    else
        packedInfo |= 1 << index;
}

inline int GetBulletGridIndexFromId(int3 xyz)
{
    xyz = clamp(xyz, int3(0, 0, 0), int3(bulletGridLengthX - 1, 0, bulletGridLengthZ - 1));
    return xyz.z * bulletGridLengthX + xyz.x;
}

inline int GetBulletGridIndexFromPos(float3 pos)
{
    int3 xyz = floor((pos - bulletGridBottomLeftPos + 0.00001f) * bulletGridSizeInv);
    xyz = clamp(xyz, int3(0, 0, 0), int3(bulletGridLengthX - 1, 0, bulletGridLengthZ - 1));
    return xyz.z * bulletGridLengthX + xyz.x;
}

inline int GetBulletGridIndexFromXZ(int x, int z)
{
    return z * bulletGridLengthX + x;
}

inline int GetEnemyGridIndexFromPos(float3 pos)
{
    int3 xyz = floor((pos - enemyGridBottomLeftPos + 0.00001f) * enemyGridSizeInv);
    xyz = clamp(xyz, int3(0, 0, 0), int3(enemyGridLengthX - 1, 0, enemyGridLengthZ - 1));
    return xyz.z * enemyGridLengthX + xyz.x;
}

inline bool IsInViewFrustum(float3 pos, float radius)
{   
    if (pos.z + radius < viewFrustrumZMin) return false;
    if (pos.z - radius > viewFrustrumZMax) return false;
    
    float xBound = lerp(
        viewFrustrumXAtZMin,
        viewFrustrumXAtZMax,
        (pos.z - viewFrustrumZMin) * viewFrustrumCullingLerpCoefficient
    );
    
    if (pos.x + radius < -xBound) return false;
    if (pos.x - radius > xBound) return false;
    
    return true;
}

inline bool InThePlane(float3 pos)
{
    bool ret = true;
    return (pos.x >= planeXMin - 0.5f) &&
        (pos.x < planeXMax + 0.5f) &&
        (pos.z > planeZMin - 0.5f) &&
        (pos.z < planeZMax + 0.5f) &&
        (pos.y >= 0.1f);
}

inline float3 PackedUIntColorToFloat3(uint color)
{
    float3 ret;
    ret.r = (color >> 24 & 255) / 255.0f;
    ret.g = (color >> 16 & 255) / 255.0f;
    ret.b = (color >> 8 & 255) / 255.0f;
    
    return ret;
}


[numthreads(256, 1, 1)]
void PlayerShoot(uint3 id : SV_DispatchThreadID)
{
    if (id.x < playerShootRequestNum)
    {
        int index;
        InterlockedAdd(playerBulletNum[0], 1, index);
        playerBulletData[index] = playerShootRequestData[id.x];
    }
}


[numthreads(256, 1, 1)]
void BossShoot(uint3 id : SV_DispatchThreadID)
{
    if (id.x < bossShootRequestNum)
    {
        int index;
        InterlockedAdd(enemyBulletNum[0], 1, index);
        enemyBulletData[index] = bossShootRequestData[id.x];
    }
}


[numthreads(128, 1, 1)]
void CreateSphereEnemy(uint3 id : SV_DispatchThreadID)
{
    if (id.x < createSphereEnemyRequestNum)
    {
        int index;
        InterlockedAdd(deployingSphereEnemyNum[0], 1, index);
        deployingSphereEnemyData[index] = createSphereEnemyRequestData[id.x];
    }
}


[numthreads(128, 1, 1)]
void UpdateDeployingEnemy(uint3 id : SV_DispatchThreadID)
{
    if (id.x < deployingSphereEnemyNum[0])
    {
        EnemyDatum enemy = deployingSphereEnemyData[id.x];
        int index;
        if (enemy.createdTime > gameTime)
        {
            InterlockedAdd(culledDeployingSphereEnemyNum[0], 1, index);
            culledDeployingSphereEnemyData[index] = enemy;
        }
        else
        {
            InterlockedAdd(sphereEnemyNum[0], 1, index);
            sphereEnemyData[index] = enemy;
        }
    }
}


[numthreads(256, 1, 1)]
void UpdatePlayerBulletPosition(uint3 id : SV_DispatchThreadID)
{
    if (id.x < playerBulletNum[0])
    {
        BulletDatum bullet = playerBulletData[id.x];
        
        if (playerSkillData[0].player1Skill1 == 2 && GetBit(bullet.packedInfo, 1))
        {
            float3 bulletVelocity = bullet.dir * bullet.speed;
            float3 aimingPointPos = playerSkillData[0].player1Skill1AimingPointPosition;
            float3 aimingPointRelativePos = aimingPointPos - bullet.pos;
            bullet.dir += normalize(aimingPointRelativePos) * 0.7f * bullet.speed * deltaTime;
            bullet.dir = normalize(bullet.dir);
            bullet.dir.y = 0.0f;
            if (length(aimingPointRelativePos) < 0.2f)
            {
                SetBit(bullet.packedInfo, 1, 0);
            }
        }
        
        bullet.pos += bullet.speed * bullet.dir * deltaTime;
        playerBulletData[id.x] = bullet;
    }
}


[numthreads(256, 1, 1)]
void UpdateEnemyBulletVelocityAndPosition(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= enemyBulletNum[0]) return;
    
    BulletDatum bullet = enemyBulletData[id.x];
    
    if (playerSkillData[0].player1Skill0 == 1)
    {
        float3 playerDir = (player1Pos - bullet.pos) * float3(1.0f, 0.0f, 1.0f);
        float playerDistance = length(playerDir);
        playerDir = normalize(playerDir);
        float3 bulletVelocity = bullet.speed * bullet.dir;
        bulletVelocity += clamp(1.0f / (playerDistance * playerDistance), 0.2f, 0.3f) * playerDir;
        bullet.speed = lerp(bullet.speed, length(bulletVelocity), 0.1);
        bullet.dir = normalize(bulletVelocity);
        bullet.pos += bulletVelocity * deltaTime;
        enemyBulletData[id.x] = bullet;
    }
    else
    {
        enemyBulletData[id.x].pos = bullet.pos + bullet.speed * bullet.dir * deltaTime;
    }
}


[numthreads(256, 1, 1)]
void CullPlayerBullet(uint3 id : SV_DispatchThreadID)
{
    BulletDatum bullet = playerBulletData[id.x];
    if (id.x < playerBulletNum[0]
        && IsInViewFrustum(bullet.pos, bullet.radius)
        && bullet.expirationTime > gameTime 
        && bullet.bounces > 0)
    {
        int index;
        InterlockedAdd(culledPlayerBulletNum[0], 1, index);
        culledPlayerBulletData[index] = bullet;
    }
}


[numthreads(256, 1, 1)]
void CullEnemyBullet(uint3 id : SV_DispatchThreadID)
{
    BulletDatum bullet = enemyBulletData[id.x];
    if (id.x < enemyBulletNum[0]
        && IsInViewFrustum(bullet.pos, bullet.radius)
        && bullet.expirationTime > gameTime
        && bullet.bounces > 0)
    {
        int index;
        InterlockedAdd(culledEnemyBulletNum[0], 1, index);
        culledEnemyBulletData[index] = bullet;
    }
}


[numthreads(128, 1, 1)]
void CullSphereEnemy(uint3 id : SV_DispatchThreadID)
{
    EnemyDatum enemy = sphereEnemyData[id.x];
    if (id.x < sphereEnemyNum[0])
    {
        if (enemy.pos.y > -5.0f)
        {
            int index;
            InterlockedAdd(culledSphereEnemyNum[0], 1, index);
            culledSphereEnemyData[index] = enemy;
        }
        else
        {
            InterlockedAdd(deadEnemyNum[0], 1);
        }
    }
}


[numthreads(1, 1, 1)]
void UpdateDrawPlayerBulletArgs(uint3 id : SV_DispatchThreadID)
{
    drawPlayerBulletArgs[1] = playerBulletNum[0];
}


[numthreads(1, 1, 1)]
void UpdateDrawEnemyBulletArgs(uint3 id : SV_DispatchThreadID)
{
    drawEnemyBulletArgs[1] = enemyBulletNum[0];
}


[numthreads(1, 1, 1)]
void UpdateDrawEnemyArgs(uint3 id : SV_DispatchThreadID)
{
    drawSphereEnemyArgs[1] = sphereEnemyNum[0];
    drawDeployingSphereEnemyArgs[1] = deployingSphereEnemyNum[0];
}


/*
[numthreads(256, 1, 1)]
void ProcessPlayerBulletCollision(uint3 id : SV_DispatchThreadID)
{
    if (id.x < playerBulletNum[0])
    {
        BulletDatum bullet = playerBulletData[id.x];
   
        for (int i = 0; i < sphereEnemyNum[0]; i++)
        {
            EnemyDatum enemy = sphereEnemyData[i];
            if (enemy.knockedOutByBoss == 1) continue;
            float enemyRadius = enemy.size * 0.5f;
            float3 bulletRelativePos = bullet.pos - enemy.pos;
            
            if (length(bulletRelativePos) <= enemyRadius + bullet.radius)
            {
                InterlockedAdd(sphereEnemyData[i].hp, -bullet.damage);
                float3 normal = normalize(bulletRelativePos);
                float3 impulse = 10000.0f * bullet.impulse * normal * min(0.0f, dot(bullet.dir, normal));
                InterlockedAdd(sphereEnemyData[i].hitImpulse.x, (int)impulse.x);
                InterlockedAdd(sphereEnemyData[i].hitImpulse.z, (int)impulse.z);
                bullet.pos = enemy.pos + (enemyRadius + bullet.radius) * normal;
                bullet.dir -= 2.0f * dot(normal, bullet.dir) * normal;
                bullet.dir.y = 0.0f;
                bullet.dir = normalize(bullet.dir);
                bullet.bounces -= 1;
                SetBit(bullet.packedInfo, 1, 0);
                playerBulletData[id.x] = bullet;
                return;
            }
        }
    }
}
*/


[numthreads(256, 1, 1)]
void ProcessPlayerBulletCollision(uint3 id : SV_DispatchThreadID)
{
    if (id.x < playerBulletNum[0])
    {
        BulletDatum bullet = playerBulletData[id.x];
        int cellIndex = GetEnemyGridIndexFromPos(bullet.pos);
        for (int biasX = -1; biasX <= 1; biasX++)
        {
            for (int biasZ = -1; biasZ <= 1; biasZ++)
            {
                int anotherCellIndex = cellIndex + biasX + biasZ * enemyGridLengthX;
                if (anotherCellIndex < 0 || anotherCellIndex >= enemyGridLength)
                    continue;
                EnemyGridDatum anotherCell = enemyGridData[anotherCellIndex];
                for (int i = 0; i < 3; i++)
                {
                    if (i == anotherCell.size)
                        break;
                    int anotherEnemyIndex = anotherCell.index[i];
                    if (anotherEnemyIndex == id.x)
                        continue;
                    EnemyDatum enemy = sphereEnemyData[anotherEnemyIndex];
                    if (enemy.knockedOutByBoss == 1)
                        continue;
                    float enemyRadius = enemy.size * 0.5f;
                    float3 bulletRelativePos = bullet.pos - enemy.pos;
            
                    if (length(bulletRelativePos) <= enemyRadius + bullet.radius)
                    {
                        InterlockedAdd(sphereEnemyData[anotherEnemyIndex].hp, -bullet.damage);
                        float3 normal = normalize(bulletRelativePos);
                        float3 impulse = 10000.0f * bullet.impulse * normal * min(0.0f, dot(bullet.dir, normal));
                        InterlockedAdd(sphereEnemyData[anotherEnemyIndex].hitImpulse.x, (int) impulse.x);
                        InterlockedAdd(sphereEnemyData[anotherEnemyIndex].hitImpulse.z, (int) impulse.z);
                        bullet.pos = enemy.pos + (enemyRadius + bullet.radius) * normal;
                        bullet.dir -= 2.0f * dot(normal, bullet.dir) * normal;
                        bullet.dir.y = 0.0f;
                        bullet.dir = normalize(bullet.dir);
                        bullet.bounces -= 1;
                        SetBit(bullet.packedInfo, 1, 0);
                        playerBulletData[id.x] = bullet;
                        return;
                    }
                }
            }
        }
    }
}


[numthreads(256, 1, 1)]
void ProcessPlayerBulletBossCollision(uint3 id : SV_DispatchThreadID)
{
    if (id.x < playerBulletNum[0])
    {
        BulletDatum bullet = playerBulletData[id.x];
        float3 bossPos = bossData[0].pos;
        float3 bossRelativePos = bullet.pos - bossPos;
        
        if (length(bossRelativePos) <= 0.5f + bullet.radius)
        {
            InterlockedAdd(bossData[0].hpChange, -bullet.damage);
            float3 normal = normalize(bossRelativePos);
            float3 impulse = 10000.0f * bullet.impulse * normal * min(0.0f, dot(bullet.dir, normal));
            InterlockedAdd(bossData[0].hitImpulse.x, (int) impulse.x);
            InterlockedAdd(bossData[0].hitImpulse.z, (int) impulse.z);
            bullet.pos = bossPos + (0.5f + bullet.radius) * normal;
            bullet.dir -= 2.0f * dot(normal, bullet.dir) * normal;
            bullet.dir.y = 0.0f;
            bullet.dir = normalize(bullet.dir);
            bullet.bounces -= 1;
            SetBit(bullet.packedInfo, 1, 0);
            playerBulletData[id.x] = bullet;
        }
    }
}


[numthreads(256, 1, 1)]
void ProcessEnemyBulletCollision(uint3 id : SV_DispatchThreadID)
{
    if (id.x < enemyBulletNum[0])
    {
        BulletDatum bullet = enemyBulletData[id.x];
   
        for (int i = 0; i < 2; i++)
        {
            PlayerDatum player = playerData[i];
            float playerRadius = player.size * 0.5f;
            float3 bulletRelativePos = bullet.pos - player.pos;
            
            if (length(bulletRelativePos) <= playerRadius + bullet.radius)
            {
                float3 normal = normalize(bulletRelativePos);
                bullet.pos = player.pos + (playerRadius + bullet.radius) * normal;
                bullet.dir -= 2.0f * dot(normal, bullet.dir) * normal;
                bullet.dir.y = 0.0f;
                bullet.dir = normalize(bullet.dir);
                bullet.bounces -= 1;
                if (i == 1 && playerSkillData[0].player2Skill0 == 1)
                {
                    InterlockedAdd(playerSkillData[0].player2Skill0HPRestoration, bullet.damage);
                    bullet.virtualY = 10.0f;
                    SetBit(bullet.packedInfo, 0, 1);
                    bullet.color = packedPlayer2BulletColor;
                    int newIndex;
                    InterlockedAdd(playerBulletNum[0], 1, newIndex);
                    playerBulletData[newIndex] = bullet;
                    enemyBulletData[id.x].pos = float3(-100.0f, 0.0f, -100.0f);
                }
                else
                {
                    InterlockedAdd(playerData[i].hpChange, -bullet.damage);
                    InterlockedAdd(playerData[i].hitImpulse.x, (int) (-normal.x * bullet.impulse * 10000.0f));
                    InterlockedAdd(playerData[i].hitImpulse.z, (int) (-normal.z * bullet.impulse * 10000.0f));
                    enemyBulletData[id.x] = bullet;
                }
                
                return;
            }
        }
    }
}


[numthreads(128, 1, 1)]
void UpdateEnemyVelocityAndPosition(uint3 id : SV_DispatchThreadID)
{
    int knockedOutByBoss = sphereEnemyData[id.x].knockedOutByBoss;
    
    // apply and clear impulse
    if (id.x < sphereEnemyNum[0] && knockedOutByBoss == 0)
    {
        EnemyDatum enemy = sphereEnemyData[id.x];

        float3 dV = (float3) enemy.hitImpulse * 0.0001 / enemy.m;
        if (length(dV) > 0.001f)
            dV = normalize(dV) * clamp(length(dV), 0.0f, 5.0f);
        enemy.velocity += dV;
        enemy.hitImpulse = int3(0, 0, 0);
        enemy.m = enemy.hp <= 0 ? enemy.originalM * 0.18f : enemy.originalM;
        sphereEnemyData[id.x] = enemy;
    }
    
    GroupMemoryBarrierWithGroupSync();
    
    EnemyDatum enemy = sphereEnemyData[id.x];
    // calculate desired velocity
    if (id.x < sphereEnemyNum[0] && knockedOutByBoss == 0)
    {
        // move towards player
        float3 player1Pos = playerData[0].pos;
        float3 player2Pos = playerData[1].pos;
        float3 player1RelativePos = player1Pos - enemy.pos;
        float3 player2RelativePos = player2Pos - enemy.pos;
        
        float3 dir;
        if (InThePlane(player1Pos))
        {
            if (playerSkillData[0].sharedSkill1 == 1)
            {
                dir = -player1RelativePos;
            }
            else if (InThePlane(player2Pos))
            {
                dir = length(player1RelativePos) < length(player2RelativePos) ?
                player1RelativePos : player2RelativePos;
            }
            else
            {
                dir = player1RelativePos;
            }
            enemy.velocity += enemy.acceleration * normalize(dir * float3(1.0f, 0.0f, 1.0f)) * deltaTime;
            enemy.velocity -= normalize(enemy.velocity) * enemy.frictionalDeceleration * max(0.0f, (length(enemy.velocity) - enemy.maxSpeed)) * deltaTime;
        }
        else
        {
            if (InThePlane(player2Pos))
            {
                dir = player2RelativePos;
                enemy.velocity += enemy.acceleration * normalize(dir * float3(1.0f, 0.0f, 1.0f)) * deltaTime;
                enemy.velocity -= normalize(enemy.velocity) * enemy.frictionalDeceleration * max(0.0f, (length(enemy.velocity) - enemy.maxSpeed)) * deltaTime;
            }
            else
            {
                float dV = min(enemy.acceleration * deltaTime, length(enemy.velocity));
                if (length(enemy.velocity) > 0.01f)
                    enemy.velocity += dV * normalize(-enemy.velocity * float3(1.0f, 0.0f, 1.0f));
                if (length(enemy.velocity) > 0.01f)
                    enemy.velocity -= normalize(enemy.velocity) * enemy.frictionalDeceleration * max(0.0f, (length(enemy.velocity) - enemy.maxSpeed)) * deltaTime;
            }
        }
    }
    
    GroupMemoryBarrierWithGroupSync();
    
    // update position
    if (id.x < sphereEnemyNum[0])
    {
        if (knockedOutByBoss == 0)
        {
            enemy.pos += enemy.velocity * deltaTime * float3(1.0f, 0.0f, 1.0f);
            sphereEnemyData[id.x] = enemy;
        }
        else
        {
            enemy.pos += enemy.velocity * deltaTime;
            sphereEnemyData[id.x] = enemy;
        }
    }
}


[numthreads(128, 1, 1)]
void ResolveEnemyCollision1(uint3 id : SV_DispatchThreadID)
{
    float3 deltaPos = float3(0.0f, 0.0f, 0.0f);
    float3 deltaVelocity = float3(0.0f, 0.0f, 0.0f);
    if (id.x < sphereEnemyNum[0] && sphereEnemyData[id.x].knockedOutByBoss == 0)
    {
        EnemyDatum enemy = sphereEnemyData[id.x];
        int cellIndex = GetEnemyGridIndexFromPos(enemy.pos);
        for (int biasX = -1; biasX <= 1; biasX++)
        {
            for (int biasZ = -1; biasZ <= 1; biasZ++)
            {
                int anotherCellIndex = cellIndex + biasX + biasZ * enemyGridLengthX;
                if (anotherCellIndex < 0 || anotherCellIndex >= enemyGridLength) continue;
                EnemyGridDatum anotherCell = enemyGridData[anotherCellIndex];
                for (int i = 0; i < 3; i++)
                {
                    if (i == anotherCell.size) break;
                    int anotherEnemyIndex = anotherCell.index[i];
                    if (anotherEnemyIndex == id.x) continue;
                    EnemyDatum another = sphereEnemyData[anotherEnemyIndex];
                    float3 relativePos = another.pos - enemy.pos;
                    float collisionDistance = length(relativePos) - 0.5f * (enemy.size + another.size);
                    if (collisionDistance < 0.0f)
                    {
                        float3 normal = normalize(relativePos);
                        float pushDistance = collisionDistance * (-0.5f) + 0.001f;
                        deltaPos += -normal * pushDistance;
                        float impulseValue = (1.0f + enemyCollisionVelocityRestitution) * dot(enemy.velocity - another.velocity, normal) / (1.0f / enemy.m + 1.0f / another.m);
                        deltaVelocity += -normal * abs(impulseValue) / enemy.m;
                    }
                }
            }
        }
        
        enemyCollisionCacheData[id.x].deltaPos = deltaPos;
        enemyCollisionCacheData[id.x].deltaVelocity = deltaVelocity;
    }
}


float resolveEnemyCollision2VelocityCoeff;
[numthreads(128, 1, 1)]
void ResolveEnemyCollision2(uint3 id : SV_DispatchThreadID)
{
    if (id.x < sphereEnemyNum[0] && sphereEnemyData[id.x].knockedOutByBoss == 0)
    {
        sphereEnemyData[id.x].pos += enemyCollisionCacheData[id.x].deltaPos;
        float3 newVelocity = sphereEnemyData[id.x].velocity + enemyCollisionCacheData[id.x].deltaVelocity * resolveEnemyCollision2VelocityCoeff;
        if (length(newVelocity) > 0.00001f)
        {
            newVelocity = normalize(newVelocity) * clamp(length(newVelocity), 0.0f, 20.0f);
        }
        else
        {
            sphereEnemyData[id.x].velocity = newVelocity;
        }

    }
}
        
[numthreads(128, 1, 1)]
void ApplyEnemyGravity(uint3 id : SV_DispatchThreadID)
{
    EnemyDatum enemy;
    
    if (id.x < sphereEnemyNum[0])
    {
        enemy = sphereEnemyData[id.x];
        
        if (enemy.knockedOutByBoss == 0)
        {
            float maxDistance = -1000.0f;
            float tmp;
            float3 borderAcceleration;
            tmp = planeXMin - enemy.pos.x;
            if (tmp > 0.0f)
            {
                maxDistance = tmp;
                borderAcceleration = float3(-1.0f, 0.0f, 0.0f);
            }
            tmp = enemy.pos.x - planeXMax;
            if (tmp > 0.0f)
            {
                maxDistance = tmp;
                borderAcceleration = float3(1.0f, 0.0f, 0.0f);
            }
            tmp = planeZMin - enemy.pos.z;
            if (tmp > 0.0f)
            {
                maxDistance = tmp;
                borderAcceleration = float3(0.0f, 0.0f, -1.0f);
            }
            tmp = enemy.pos.z - planeZMax;
            if (tmp > 0.0f)
            {
                maxDistance = tmp;
                borderAcceleration = float3(0.0f, 0.0f, 1.0f);
            }

            if (maxDistance <= 0.0f && enemy.velocity.y >= -0.01f)
            {
                sphereEnemyData[id.x].velocity.y = 0.0f;
                sphereEnemyData[id.x].pos.y = 0.5f;
            }
            else
            {
                float YLimit = -10005.0f;
                if (maxDistance > 0.0f && maxDistance < 0.5f && enemy.pos.y > 0.0f)
                {
                    YLimit = sqrt(0.25f - maxDistance * maxDistance);
                }
                float maxFallDistance = 0.5f * gravity * deltaTime * deltaTime;
                enemy.pos.y += sphereEnemyData[id.x].velocity.y * deltaTime;
                sphereEnemyData[id.x].pos.y = max(enemy.pos.y, YLimit);
                sphereEnemyData[id.x].velocity.y -= gravity * deltaTime;
                sphereEnemyData[id.x].velocity += borderAcceleration * deltaTime;
            }
        }
        else
        {
            sphereEnemyData[id.x].velocity.y -= gravity * deltaTime;
        }
    }
}


[numthreads(128, 1, 1)]
void ProcessPlayerEnemyCollision(uint3 id : SV_DispatchThreadID)
{
    if (id.x < sphereEnemyNum[0])
    {
        EnemyDatum enemy = sphereEnemyData[id.x];
        if (enemy.knockedOutByBoss == 1) return;
        
        for (int i = 0; i < 2; i++)
        {
            PlayerDatum player = playerData[i];
            if (player.hittable || (i == 1 && playerSkillData[0].player2Skill0 == 1))
            {
                float3 relativePos = player.pos - enemy.pos;
                float distance = length(relativePos);
                float minDistance = (player.size + enemy.size) * 0.5;
                if (distance < minDistance)
                {
                    if (playerSkillData[0].player2Skill0 == 1 && i == 1)
                    {
                        if (gameTime - enemy.lastHitByPlayer2Skill0Time >= player2Skill0TMax)
                            enemy.lastHitByPlayer2Skill0Time = gameTime;
                        InterlockedAdd(playerSkillData[0].player2Skill0HitEnemy, 1);
                        float3 dir = normalize(relativePos);
                        enemy.velocity = float3(0.0f, 0.0f, 0.0f);
                        enemy.pos = player.pos - dir * minDistance;
                        float3 dV = -dir * 3.0f;
                        
                        // extra normal impulse
                        if (length(player.velocity > 0.1f))
                        {
                            float3 playerVelocityNormal = normalize(float3(player.velocity.z, 0.0f, -player.velocity.x));
                            if (dot(playerVelocityNormal, -dir) > 0.0f)
                                dV += playerVelocityNormal * 6.0f;
                            else
                                dV -= playerVelocityNormal * 6.0f;
                        }
                            
                        dV.y = 0.0f;
                        enemy.velocity += dV;
                        
                        sphereEnemyData[id.x] = enemy;
                    }
                    else if (player.hittable == 1)
                    {
                        float3 dir = normalize(relativePos);
                        float3 dV = dir * 12.0f;
                        dV.y = 8.0f;
                        playerData[i].hitByEnemy = 1;
                        playerData[i].hitImpulse = 10000.0f * dV;
                        InterlockedAdd(playerData[i].hpChange, -30);
                    }
                }
            }
        }
    }
}


[numthreads(128, 1, 1)]
void ProcessBossEnemyCollision(uint3 id : SV_DispatchThreadID)
{
    if (id.x < sphereEnemyNum[0] && sphereEnemyData[id.x].knockedOutByBoss == 0)
    {
        EnemyDatum enemy = sphereEnemyData[id.x];
        BossDatum boss = bossData[0];
        
        float3 relativePos = boss.pos - enemy.pos;
        float distance = length(relativePos);
        float minDistance = 0.5f + 0.5f * enemy.size;
        if (distance < minDistance)
        {
            if (gameTime - enemy.lastHitByPlayer2Skill0Time >= player2Skill0TMax)
                enemy.lastHitByPlayer2Skill0Time = gameTime;
            float3 dir = normalize(relativePos);
            enemy.velocity = float3(0.0f, 0.0f, 0.0f);
            enemy.pos = boss.pos - dir * minDistance;
            float3 dV = -dir * 2.0f;
                        
            float3 bossVelocityNormal = normalize(float3(boss.velocity.z, 0.0f, -boss.velocity.x));
            if (dot(bossVelocityNormal, -dir) > 0.0f)
                dV += bossVelocityNormal * 4.5f;
            else
                dV -= bossVelocityNormal * 4.5f;
                        
            dV.y = 0.0f;
            enemy.velocity += dV;
            sphereEnemyData[id.x] = enemy;
        }
    }
}


[numthreads(128, 1, 1)]
void EnemyShoot(uint3 id : SV_DispatchThreadID)
{
    EnemyDatum enemy = sphereEnemyData[id.x];
    if (id.x < sphereEnemyNum[0] && enemy.knockedOutByBoss == 0)
    {
        EnemyWeaponDatum weapon = enemyWeaponData[enemy.weapon];
        float3 r3 = Random3DTo3D(float3(gameTime, deltaTime, float(id.x) + deltaTime));
        
        if (weapon.shootInterval > 0
            && gameTime - enemy.lastShootTime > weapon.shootInterval + weapon.randomShootDelay * r3.x
            && enemy.pos.y > 0.499f)
        {
            sphereEnemyData[id.x].lastShootTime = gameTime;
            
            float3 player1Pos = playerData[0].pos;
            float3 player2Pos = playerData[1].pos;
            
            float3 playerDir;
            float3 player1RelativePos = player1Pos - enemy.pos;
            float3 player2RelativePos = player2Pos - enemy.pos;
            if (InThePlane(player1Pos))
            {
                if (playerSkillData[0].sharedSkill1 == 1)
                {
                    playerDir = -player1RelativePos;
                }
                else if (InThePlane(player2Pos))
                {
                    playerDir = length(player1RelativePos) < length(player2RelativePos) ?
                    player1RelativePos : player2RelativePos;
                }
                else
                {
                    playerDir = player1RelativePos;
                }
            }
            else
            {
                if (InThePlane(player2Pos))
                {
                    playerDir = player2RelativePos;
                }
                else
                {
                    return;
                }
            }
            playerDir = normalize(playerDir * float3(1.0f, 0.0f, 1.0f));

            for (int i = -weapon.extraBulletsPerSide; i <= weapon.extraBulletsPerSide; i++)
            {
                int bulletIndex;
                InterlockedAdd(enemyBulletNum[0], 1, bulletIndex);
                BulletDatum bullet = enemyBulletData[bulletIndex];
                float r1 = Random3DTo1D(gameTime, (float)i * 14375.5964, deltaTime) + r3.z;
                 
                bullet.pos = enemy.pos;
                bullet.dir = RotateAroundY(playerDir, i * weapon.angle + weapon.uniformRandomAngleBias * (r3.y * 2.0f - 1.0f));
                bullet.dir.y = 0.0f;
                bullet.speed = weapon.bulletSpeed;
                bullet.radius = weapon.bulletRadius;
                bullet.damage = weapon.bulletDamage;
                bullet.bounces = weapon.bulletBounces;
                bullet.expirationTime = gameTime + weapon.bulletLifeSpan;
                bullet.impulse = weapon.bulletImpulse;
                bullet.virtualY = 0.5f + (r1 - 0.5) * weapon.virtualYRange * 2.0f;
                bullet.color = enemy.baseColor;
                enemyBulletData[bulletIndex] = bullet;
            }
        }
    }
}


[numthreads(256, 1, 1)]
void ResetBulletGrid(uint3 id : SV_DispatchThreadID)
{
    playerBulletGridData[id.x].size = 0;
    enemyBulletGridData[id.x].size = 0;
}


[numthreads(256, 1, 1)]
void BuildPlayerBulletGrid(uint3 id : SV_DispatchThreadID)
{
    if (id.x < playerBulletNum[0])
    {
        float3 pos = playerBulletData[id.x].pos;
        int gridIndex = GetBulletGridIndexFromPos(pos);
        int bulletIndex;
        InterlockedAdd(playerBulletGridData[gridIndex].size, 1, bulletIndex);
        if (bulletIndex < BULLET_GRID_CAPACITY)
        {
            playerBulletGridData[gridIndex].bulletIndexList[bulletIndex] = id.x;
        }
    }
}


[numthreads(256, 1, 1)]
void BuildEnemyBulletGrid(uint3 id : SV_DispatchThreadID)
{
    if (id.x < enemyBulletNum[0])
    {
        float3 pos = enemyBulletData[id.x].pos;
        int gridIndex = GetBulletGridIndexFromPos(pos);
        int bulletIndex;
        InterlockedAdd(enemyBulletGridData[gridIndex].size, 1, bulletIndex);
        if (bulletIndex < BULLET_GRID_CAPACITY)
        {
            enemyBulletGridData[gridIndex].bulletIndexList[bulletIndex] = id.x;
        }
    }
}


[numthreads(8, 1, 8)]
void ProcessBulletBulletCollision(uint3 id : SV_DispatchThreadID)
{
    int gridIndex = GetBulletGridIndexFromId(id);
    for (int i = 0; i < min(playerBulletGridData[gridIndex].size, BULLET_GRID_CAPACITY); i++)
    {
        int playerBulletIndex = playerBulletGridData[gridIndex].bulletIndexList[i];
        BulletDatum playerBullet = playerBulletData[playerBulletIndex];
        for (int gridBiasX = -1; gridBiasX <= 1; gridBiasX++)
        {
            for (int gridBiasZ = -1; gridBiasZ <= 1; gridBiasZ++)
            {
                int neighborGridIndex = GetBulletGridIndexFromId(id + int3(gridBiasX, 0, gridBiasZ));
                for (int j = 0; j < min(enemyBulletGridData[neighborGridIndex].size, BULLET_GRID_CAPACITY); j++)
                {
                    int enemyBulletIndex = enemyBulletGridData[neighborGridIndex].bulletIndexList[j];
                    BulletDatum enemyBullet = enemyBulletData[enemyBulletIndex];
                    float radiusSum = playerBullet.radius + enemyBullet.radius;
                    if (length(playerBullet.pos - enemyBullet.pos) < radiusSum
                        && abs(playerBullet.virtualY - enemyBullet.virtualY) < radiusSum)
                    {
                        playerBulletData[playerBulletIndex].expirationTime = 0.0f;
                        enemyBulletData[enemyBulletIndex].expirationTime = 0.0f;
                    }
                }
            }
        }
    }
}


[numthreads(256, 1, 1)]
void SkillTransferBulletType(uint3 id : SV_DispatchThreadID)
{
    int state = playerSkillData[0].sharedSkill0;
    float player1BulletRate = state == 3 ? 0.8f : 0.2f;
    
    if (id.x < enemyBulletNum[0])
    {
        int index;
        InterlockedAdd(playerBulletNum[0], 1, index);
        float r = Random3DTo1D(gameTime * 100.0f, id.x * 0.5f, index * 0.5f);
        int createdByPlayer1 = r < player1BulletRate;
        BulletDatum bullet = enemyBulletData[id.x];
        bullet.damage = createdByPlayer1 ? 2.0f : 0.5f;
        bullet.impulse = createdByPlayer1 ? 1.0f : 2.0f;
        bullet.renderingBiasY = createdByPlayer1 ? 0.0f : 1.0f;
        SetBit(bullet.packedInfo, 0, createdByPlayer1 ? 0 : 1);
        uint packedColor = createdByPlayer1 ? packedPlayer1BulletColor : packedPlayer2BulletColor;
        bullet.color = packedColor;
        playerBulletData[index] = bullet;
    }
}


// range: x = [-18, 18], z = [-13, 13]
#define TEST_POSITION_START float3(-17.9296875f, 0.5f, -12.94921875)
#define TEST_POSITION_STEP float3(0.140625f, 0.0f, 0.1015625f)
[numthreads(16, 1, 16)]
void SkillGetAvailablePosition(uint3 id : SV_DispatchThreadID)
{
    float3 currentPos = TEST_POSITION_START + TEST_POSITION_STEP * id;
    for (int i = 0; i < sphereEnemyNum[0]; i++)
    {
        if (length(sphereEnemyData[i].pos - currentPos) < 2.0f)
        {
            return;
        }
    }
    
    int index;
    InterlockedAdd(availablePositionData[0].num, 1, index);
    if (index == 0)
    {
        availablePositionData[0].pos1 = currentPos;
    }
    else if (index == 1)
    {
        if (length(availablePositionData[0].pos1 - currentPos) > 2.0f)
        {
            availablePositionData[0].pos2 = currentPos;
        }
        else
        {
            availablePositionData[0].num = 1;
        }
    }
}


[numthreads(256, 1, 1)]
void ResetBulletRenderingGrid(uint3 id : SV_DispatchThreadID)
{
    bulletRenderingGridData1x1[id.x].size = 0;
    bulletRenderingGridData2x2[id.x].size = 0;
    bulletRenderingGridData4x4[id.x].size = 0;
}


[numthreads(8, 1, 8)]
void ResolveBulletRenderingGrid1x1(uint3 id : SV_DispatchThreadID)
{
    int index = GetBulletGridIndexFromId(id);

    for (int i = 0; i < min(playerBulletGridData[index].size, 1); i++)
    {
        BulletDatum bullet = playerBulletData[playerBulletGridData[index].bulletIndexList[i]];
        bool valid = true;
        
        /*
        for (int j = 0; j < sphereEnemyNum[0]; j++)
        {
            if (length(bullet.pos - sphereEnemyData[j].pos) <= 0.5f)
            {
                valid = false;
                break;
            }
        }
        */
        
        
        int cellIndex = GetEnemyGridIndexFromPos(bullet.pos);
        for (int biasX = -1; biasX <= 1; biasX++)
        {
            for (int biasZ = -1; biasZ <= 1; biasZ++)
            {
                int anotherCellIndex = cellIndex + biasX + biasZ * enemyGridLengthX;
                if (anotherCellIndex < 0 || anotherCellIndex >= enemyGridLength)
                    continue;
                EnemyGridDatum anotherCell = enemyGridData[anotherCellIndex];
                for (int j = 0; j < 3; j++)
                {
                    if (j == anotherCell.size)
                        break;
                    int enemyIndex = anotherCell.index[j];
                    if (length(bullet.pos - sphereEnemyData[enemyIndex].pos) <= 0.5f)
                    {
                        valid = false;
                        break;
                    }
                }
            }
        }
        
        
        if (valid)
        {
            int size = bulletRenderingGridData1x1[index].size;
            bulletRenderingGridData1x1[index].color[size] = PackedUIntColorToFloat3(bullet.color);
            bulletRenderingGridData1x1[index].pos[size] = bullet.pos;
            bulletRenderingGridData1x1[index].size++;
        }
    }
    
    for (int i = 0; i < min(enemyBulletGridData[index].size, 1); i++)
    {
        BulletDatum bullet = enemyBulletData[enemyBulletGridData[index].bulletIndexList[i]];
        bool valid = true;
        int cellIndex = GetEnemyGridIndexFromPos(bullet.pos);
        for (int biasX = -1; biasX <= 1; biasX++)
        {
            for (int biasZ = -1; biasZ <= 1; biasZ++)
            {
                int anotherCellIndex = cellIndex + biasX + biasZ * enemyGridLengthX;
                if (anotherCellIndex < 0 || anotherCellIndex >= enemyGridLength)
                    continue;
                EnemyGridDatum anotherCell = enemyGridData[anotherCellIndex];
                for (int j = 0; j < 3; j++)
                {
                    if (j == anotherCell.size)
                        break;
                    int enemyIndex = anotherCell.index[j];
                    if (length(bullet.pos - sphereEnemyData[enemyIndex].pos) <= 0.5f)
                    {
                        valid = false;
                        break;
                    }
                }
            }
        }
        
        if (valid)
        {
            int size = bulletRenderingGridData1x1[index].size;
            bulletRenderingGridData1x1[index].color[size] = PackedUIntColorToFloat3(bullet.color);
            bulletRenderingGridData1x1[index].pos[size] = bullet.pos;
            bulletRenderingGridData1x1[index].size++;
        }
    }
}


groupshared float3 colorCache[9][9];
groupshared float3 posCache[9][9];
groupshared int bulletNumCache[9][9];

[numthreads(8, 1, 8)]
void ResolveBulletRenderingGrid2x2(uint3 id : SV_DispatchThreadID, uint3 groupThreadID : SV_GroupThreadID)
{
    int bulletNum = 0;
    float3 colorSum = float3(0.0f, 0.0f, 0.0f);
    float3 posSum = float3(0.0f, 0.0f, 0.0f);
    int cellIndex = GetBulletGridIndexFromXZ(id.x, id.z);
    int cellSize = bulletRenderingGridData1x1[cellIndex].size;
    for (int i = 0; i < min(2, cellSize); i++)
    {
        bulletNum++;
        colorSum += bulletRenderingGridData1x1[cellIndex].color[i];
        posSum += bulletRenderingGridData1x1[cellIndex].pos[i];
    }
    float bulletNumInv = bulletNum == 0 ? 0.0f : 1.0f / bulletNum;
    colorCache[groupThreadID.x][groupThreadID.z] = colorSum;
    posCache[groupThreadID.x][groupThreadID.z] = posSum * bulletNumInv;
    bulletNumCache[groupThreadID.x][groupThreadID.z] = bulletNum;
    
    if (groupThreadID.x == 7)
    {
        int bulletNum = 0;
        float3 colorSum = float3(0.0f, 0.0f, 0.0f);
        float3 posSum = float3(0.0f, 0.0f, 0.0f);
        int cellIndex = GetBulletGridIndexFromXZ(id.x + 1, id.z);
        int cellSize = bulletRenderingGridData1x1[cellIndex].size;
        for (int i = 0; i < min(2, cellSize); i++)
        {
            bulletNum++;
            colorSum += bulletRenderingGridData1x1[cellIndex].color[i];
            posSum += bulletRenderingGridData1x1[cellIndex].pos[i];
        }
        float bulletNumInv = bulletNum == 0 ? 0.0f : 1.0f / bulletNum;
        colorCache[groupThreadID.x + 1][groupThreadID.z] = colorSum;
        posCache[groupThreadID.x + 1][groupThreadID.z] = posSum * bulletNumInv;
        bulletNumCache[groupThreadID.x + 1][groupThreadID.z] = bulletNum;
    }
    if (groupThreadID.z == 7)
    {
        int bulletNum = 0;
        float3 colorSum = float3(0.0f, 0.0f, 0.0f);
        float3 posSum = float3(0.0f, 0.0f, 0.0f);
        int cellIndex = GetBulletGridIndexFromXZ(id.x, id.z + 1);
        int cellSize = bulletRenderingGridData1x1[cellIndex].size;
        for (int i = 0; i < min(2, cellSize); i++)
        {
            bulletNum++;
            colorSum += bulletRenderingGridData1x1[cellIndex].color[i];
            posSum += bulletRenderingGridData1x1[cellIndex].pos[i];
        }
        float bulletNumInv = bulletNum == 0 ? 0.0f : 1.0f / bulletNum;
        colorCache[groupThreadID.x][groupThreadID.z + 1] = colorSum;
        posCache[groupThreadID.x][groupThreadID.z + 1] = posSum * bulletNumInv;
        bulletNumCache[groupThreadID.x][groupThreadID.z + 1] = bulletNum;
        
        if (groupThreadID.x == 7)
        {
            int bulletNum = 0;
            float3 colorSum = float3(0.0f, 0.0f, 0.0f);
            float3 posSum = float3(0.0f, 0.0f, 0.0f);
            int cellIndex = GetBulletGridIndexFromXZ(id.x + 1, id.z + 1);
            int cellSize = bulletRenderingGridData1x1[cellIndex].size;
            for (int i = 0; i < min(2, cellSize); i++)
            {
                bulletNum++;
                colorSum += bulletRenderingGridData1x1[cellIndex].color[i];
                posSum += bulletRenderingGridData1x1[cellIndex].pos[i];
            }
            float bulletNumInv = bulletNum == 0 ? 0.0f : 1.0f / bulletNum;
            colorCache[groupThreadID.x + 1][groupThreadID.z + 1] = colorSum;
            posCache[groupThreadID.x + 1][groupThreadID.z + 1] = posSum * bulletNumInv;
            bulletNumCache[groupThreadID.x + 1][groupThreadID.z + 1] = bulletNum;
        }
    }
    
    GroupMemoryBarrierWithGroupSync();
    
    int index = GetBulletGridIndexFromId(id);
    int size = 0;
    for (int x = groupThreadID.x; x <= groupThreadID.x + 1; x++)
    {
        for (int z = groupThreadID.z; z <= groupThreadID.z + 1; z++)
        {
            if (bulletNumCache[x][z] != 0)
            {
                bulletRenderingGridData2x2[index].color[size] = colorCache[x][z];
                bulletRenderingGridData2x2[index].pos[size] = posCache[x][z];
                size++;
            }
        }
    }
    bulletRenderingGridData2x2[index].size = size;
}


/*
[numthreads(8, 1, 8)]
void ResolveBulletRenderingGrid2x2(uint3 id : SV_DispatchThreadID)
{
    int index = GetBulletGridIndexFromId(id);
    BulletRenderingGridDatum result;
    int cellSize = 0;
    for (int x = id.x; x <= id.x + 1; x++)
    {
        for (int z = id.z; z <= id.z + 1; z++)
        {
            int bulletNum = 0;
            float3 colorSum = float3(0.0f, 0.0f, 0.0f);
            float3 posSum = float3(0.0f, 0.0f, 0.0f);
            int cellIndex = GetBulletGridIndexFromXZ(x, z);
            for (int i = 0; i < 2; i++)
            {
                if (i == bulletRenderingGridData1x1[cellIndex].size)
                    break;
                bulletNum++;
                colorSum += bulletRenderingGridData1x1[cellIndex].color[i];
                posSum += bulletRenderingGridData1x1[cellIndex].pos[i];
            }
            
            if (bulletNum != 0)
            {
                float bulletNumInv = 1.0f / (float) bulletNum;
                bulletRenderingGridData2x2[index].color[cellSize] = colorSum * bulletNumInv;
                bulletRenderingGridData2x2[index].pos[cellSize] = posSum * bulletNumInv;
                cellSize++;
            }
        }
    }
     
    bulletRenderingGridData2x2[index].size = cellSize;
}
*/

// obsolete
[numthreads(8, 1, 8)]
void ResolveBulletRenderingGrid4x4(uint3 id : SV_DispatchThreadID)
{
    int bulletNum = 0;
    float3 colorSum = float3(0.0f, 0.0f, 0.0f);
    float3 posSum = float3(0.0f, 0.0f, 0.0f);
    for (int x = id.x; x <= id.x + 2; x += 2)
    {
        for (int z = id.z; z <= id.z + 2; z += 2)
        {
            int cellIndex = GetBulletGridIndexFromXZ(x, z);
            for (int i = 0; i < bulletRenderingGridData2x2[cellIndex].size; i++)
            {
                bulletNum += 1;
                colorSum += bulletRenderingGridData1x1[cellIndex].color[i];
                posSum += bulletRenderingGridData1x1[cellIndex].pos[i];
            }
        }
    }

    int index = GetBulletGridIndexFromId(id);
    if (bulletNum != 0)
    {
        float bulletNumInv = 1.0f / (float) bulletNum;
        bulletRenderingGridData4x4[index].color[0] = colorSum * bulletNumInv;
        bulletRenderingGridData4x4[index].pos[0] = posSum * bulletNumInv;
        bulletRenderingGridData4x4[index].size = 1;
    }
}


[numthreads(32, 1, 32)]
void ResetPlaneLightingTexture(uint3 id : SV_DispatchThreadID)
{
    planeLightingTexture[id.xz] = float4(0.0f, 0.0f, 0.0f, 0.0f);
}


[numthreads(256, 1, 1)]
void GeneratePlaneLightingTexture(uint3 id : SV_DispatchThreadID)
{
    if (id.x < playerBulletNum[0])
    {
        float3 pos = playerBulletData[id.x].pos;
        float3 color = PackedUIntColorToFloat3(playerBulletData[id.x].color);

        if (pos.y >= 0.0f && pos.y <= 0.6f)
        {
            int3 texIndex = floor((pos - float3(planeXMin, 0.5f, planeZMin)) * planeSizeInv *
                float3(planeLightingTextureWidth, 0.0f, planeLightingTextureHeight));
            planeLightingTexture[texIndex.xz] += float4(color, 1.0f);
        }
    }
    
    if (id.x < enemyBulletNum[0])
    {
        float3 pos = enemyBulletData[id.x].pos;
        float3 color = PackedUIntColorToFloat3(enemyBulletData[id.x].color);

        if (pos.y >= 0.0f && pos.y <= 0.6f)
        {
            int3 texIndex = floor((pos - float3(planeXMin, 0.5f, planeZMin)) * planeSizeInv *
                float3(planeLightingTextureWidth, 0.0f, planeLightingTextureHeight));
            planeLightingTexture[texIndex.xz] += float4(color, 1.0f);
        }
    }
}


[numthreads(16, 16, 1)]
void ResolvePlaneLightingTexture(uint3 id : SV_DispatchThreadID)
{
    float4 data = planeLightingTexture[id.xy];
    float weight = pow(data.a, 0.3f);
    planeLightingTexture[id.xy] = float4(data.rgb * weight, 1.0f);
}


[numthreads(160, 1, 1)]
void GaussianBlurU(uint3 id : SV_DispatchThreadID)
{
    float3 result = float3(0.0f, 0.0f, 0.0f);
    for (int i = 0; i < 7; i++)
    {
        result += planeLightingGaussianBlurWeight[i].x * planeLightingTexture[id.xy + int2(i - 3, 0)];
    }
    planeLightingTextureTmp[id.xy] = float4(result, 1.0f);
}


[numthreads(1, 150, 1)]
void GaussianBlurV(uint3 id : SV_DispatchThreadID)
{
    float3 result = float3(0.0f, 0.0f, 0.0f);
    for (int i = 0; i < 7; i++)
    {
        result += planeLightingGaussianBlurWeight[i].x * planeLightingTextureTmp[id.xy + int2(0, i - 3)];
    }
    planeLightingTexture[id.xy] = float4(result, 1.0f);
}


[numthreads(128, 1, 1)]
void KnockOutAllEnemy(uint3 id : SV_DispatchThreadID)
{
    if (id.x < sphereEnemyNum[0])
    {
        float r = Random3DTo1D(id.x, gameTime, sphereEnemyNum[0]);
        if (r > saturate(min(30.0f, sphereEnemyNum[0] * 0.5f) / sphereEnemyNum[0]))
        {
            EnemyDatum enemy = sphereEnemyData[id.x];
            float3 relativePosToCenter = enemy.pos - float3(0.0f, 0.5f, 0.0f);
            float distanceToCenter = length(relativePosToCenter);
            float speedXZ = 18.0f / (1.0f + distanceToCenter * 0.04);
            float speedY = 8.0f / (1.0f + distanceToCenter * 0.04) + r * 12.0f;
            float3 dirXZ = normalize(relativePosToCenter);
            sphereEnemyData[id.x].velocity = dirXZ * speedXZ + float3(0.0f, speedY, 0.0f);
            sphereEnemyData[id.x].knockedOutByBoss = 1;
        }
    }
}


[numthreads(32, 32, 1)]
void PhysicallyBasedBlur(uint3 id : SV_DispatchThreadID)
{
    float3 result = float3(0.0f, 0.0f, 0.0f);
    int radius = 30;
    for (int i = -radius; i <= radius; i++)
    {
        for (int j = -radius; j <= radius; j++)
        {
            if (i * i + j * j > radius * radius)
                continue;
            float dX = 40.0f / planeLightingTextureWidth * i;
            float dZ = 30.0f / planeLightingTextureHeight * j;
            float squaredHorizontalDistance = dX * dX + dZ * dZ;
            float distance = sqrt(squaredHorizontalDistance + 0.25f);
            float weight = 0.5f / (distance * distance * distance);
            result += weight * planeLightingTexture[id.xy + int2(i, j)];
        }
    }
    planeLightingTextureTmp[id.xy] = float4(result, 1.0f);
}


[numthreads(32, 32, 1)]
void CopyTexture(uint3 id : SV_DispatchThreadID)
{
    textureTo[id.xy] = textureFrom[id.xy];
}

[numthreads(32, 32, 1)]
void CopyTextureAndReverseY(uint3 id : SV_DispatchThreadID)
{
    textureTo[id.xy] = textureFrom[int2(id.x, fftTextureSize - 1 - id.y)];
}

[numthreads(16, 16, 1)]
void DFTStepU(uint3 id : SV_DispatchThreadID)
{
    int2 index1 = id.xy;
    int2 index2 = int2(id.x + int(fftTextureSize / 2), id.y);
    int k = id.x & (fftButterflySize - 1);

    float theta = -float(k) / fftButterflySize;
    ComplexFloat3 result1 = GetFFTComplexColor(index1);
    ComplexFloat3 result2 = ComplexMul(GetFFTComplexColor(index2), angleToComplex(theta * PI));
    
    int2 index1Out = int2((id.x << 1) - k, id.y);
    int2 index2Out = int2(index1Out.x + fftButterflySize, id.y);
    SetFFTComplexColor(index1Out, result1, result2, true);
    SetFFTComplexColor(index2Out, result1, result2, false);
}


[numthreads(16, 16, 1)]
void DFTStepV(uint3 id : SV_DispatchThreadID)
{
    int2 index1 = id.xy;
    int2 index2 = int2(id.x, id.y + int(fftTextureSize / 2));
    int k = id.y & (fftButterflySize - 1);

    float theta = -float(k) / fftButterflySize;
    ComplexFloat3 result1 = GetFFTComplexColor(index1);
    ComplexFloat3 result2 = ComplexMul(GetFFTComplexColor(index2), angleToComplex(theta * PI));

    int2 index1Out = int2(id.x, (id.y << 1) - k);
    int2 index2Out = int2(id.x, index1Out.y + fftButterflySize);
    SetFFTComplexColor(index1Out, result1, result2, true);
    SetFFTComplexColor(index2Out, result1, result2, false);
}


[numthreads(16, 16, 1)]
void IDFTStepU(uint3 id : SV_DispatchThreadID)
{
    int2 index1 = id.xy;
    int2 index2 = int2(id.x + int(fftTextureSize / 2), id.y);
    int k = id.x & (fftButterflySize - 1);

    float theta = float(k) / fftButterflySize;
    ComplexFloat3 result1 = GetFFTComplexColor(index1);
    ComplexFloat3 result2 = ComplexMul(GetFFTComplexColor(index2), angleToComplex(theta * PI));
    
    int2 index1Out = int2((id.x << 1) - k, id.y);
    int2 index2Out = int2(index1Out.x + fftButterflySize, id.y);
    SetFFTComplexColor(index1Out, result1, result2, true);
    SetFFTComplexColor(index2Out, result1, result2, false);
}

 
[numthreads(16, 16, 1)]
void IDFTStepV(uint3 id : SV_DispatchThreadID)
{
    int2 index1 = id.xy;
    int2 index2 = int2(id.x, id.y + int(fftTextureSize / 2));
    int k = id.y & (fftButterflySize - 1);

    float theta = float(k) / fftButterflySize;
    ComplexFloat3 result1 = GetFFTComplexColor(index1);
    ComplexFloat3 result2 = ComplexMul(GetFFTComplexColor(index2), angleToComplex(theta * PI));

    int2 index1Out = int2(id.x, (id.y << 1) - k);
    int2 index2Out = int2(id.x, index1Out.y + fftButterflySize);
    SetFFTComplexColor(index1Out, result1, result2, true);
    SetFFTComplexColor(index2Out, result1, result2, false);
}


[numthreads(32, 32, 1)]
void PlaneLightingFrequencyDomainMultiply(uint3 id : SV_DispatchThreadID)
{
    // assert the imag component of the convolution kernel in frequency domain is zero
    // because the kernel is conjugate symmetric in temporal domain
    float scale = planeLightingConvolutionKernel[id.xy].x;
    fftOutReal[id.xy] *= scale;
    fftOutImag[id.xy] *= scale;
}


[numthreads(32, 32, 1)]
void InitializePlaneLightingTemporalConvolutionKernel(uint3 id : SV_DispatchThreadID)
{
    float dX = min(id.x, fftTextureSize - id.x) * planeLightingTexturePixelSizeX;
    float dY = min(id.y, fftTextureSize - id.y) * planeLightingTexturePixelSizeY;
    float distanceInv = rsqrt(dX * dX + dY * dY + 0.25f);
    float weight = 0.5f * distanceInv * distanceInv * distanceInv;
    planeLightingConvolutionKernel[id.xy] = float4(weight, weight, weight, weight);
}


[numthreads(32, 32, 1)]
void PadPlaneLightingTexture(uint3 id : SV_DispatchThreadID)
{
    fftInReal[id.xy] = planeLightingTexture[id.xy];
}


[numthreads(32, 1, 32)]
void ClearEnemyGrid(uint3 id : SV_DispatchThreadID)
{
    enemyGridData[id.z * enemyGridLengthX + id.x].size = 0;
}


[numthreads(256, 1, 1)]
void BuildEnemyGrid(uint3 id : SV_DispatchThreadID)
{
    if (id.x < sphereEnemyNum[0])
    {
        int index = GetEnemyGridIndexFromPos(sphereEnemyData[id.x].pos);
        int cellSize;
        InterlockedAdd(enemyGridData[index].size, 1, cellSize);
        enemyGridData[index].index[cellSize] = id.x;
    }
}
